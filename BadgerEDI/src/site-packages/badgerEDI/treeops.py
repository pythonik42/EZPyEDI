'''Created on Aug 1, 2011

treeops.py

This module supplies a number of classes that can be be used to
specify and evaluate deferred data tree traversal and data mapping
operations.

We use these objects to declaratively specify the mapping operations
to be performed on operation trees that will ultimately be used to
generate docs destined for storage using various flavors of tree-structured 
data (i.e. XML, JSON, EDI X12, EDI Edifact, etc).    

This is extremely useful, as it allows the developer to cleanly prune or 
modify operational scripts specified in a tree of 'standard' operations
prior to evaluation in order to implement particular custom logic (i.e. 
EDI trading partner specific data mangling/functionality) Doing it in this 
way saves execution time, simplifies code maintenenace, and allows
for near-surgical modification/removal of output data elements without 
fear of breaking other functional pathways within the tree. 

@author: jknaus
'''

from badgerEDI import eLog

from badgerEDI.bedislib import *
from badgerEDI.ediutil import *
from badgerEDI.indentation import Indentation
from badgerEDI.dmerge import merge_dictionary

import bots.botslib

import pprint
import copy

## one-line if block
#def If(ifPart, thenPart, elsePart='pass'):
#    return '@if %s: %s else: %s' % (ifPart, thenPart, elsePart) 

# a fork in the __tree
class y(DynO): 
    
    def __init__(self, **kws):
        super(y, self).__init__(**kws)

#===============================================================================
# Tree Operations Classes    
#===============================================================================

treeopsIndentation = Indentation(' '*4, '>')  # manages our tree log printing indentation logic

#abstract
class   TreeOpBase(y):
    
    def __init__(self, mpath=None, segName=None, **kw):
        super(TreeOpBase, self).__init__(**kw)
        self._Y_segName = segName
        self._Y_resultsTree = DynO(__NAME=segName or '---')
        self._Y_mpath = mpath 
    
    def printOpMsg(self, botsLoopContextList):
        eLog.debug('%sTREE [%s] Evaluating %s in context %s',
            self.indent(), self._Y_segName, self.__class__.__name__, tuple(botsLoopContextList))
        
    def setResultValue(self, attrName, attrValue):
        self._Y_resultsTree[attrName] = attrValue
        
    def getResultsTree(self):
        if self._Y_segName:
            self._Y_resultsTree.setName(self._Y_segName)
            
        # eLog.debug('Get >> RTREE(%s)=%s' % (self._Y_resultsTree.getName(), self._Y_resultsTree))
        return self._Y_resultsTree

    def setResultsTree(self, resultsTree):
        self._Y_resultsTree = resultsTree
        # eLog.debug('Set >> RTREE(%s)=%s' % (self._Y_resultsTree.getName(), self._Y_resultsTree))
        
    def setSegName(self, segName):
        self._Y_segName = segName

    def getSegName(self):
        return self._Y_segName    
    
    def getMPath(self):
        return self._Y_mpath    
        
    def indent(self):
        return treeopsIndentation


#===============================================================================
# Tree GET operations    
#===============================================================================
        
#abstract
class GetLoopsBase(TreeOpBase): 
    
    def __init__(self, mpath=None, segName=None, **kw):
        super(GetLoopsBase, self).__init__(mpath, segName, **kw)

    def evaluateInternal(self, segName=None, parentTreeOp=None, justLoopOnce=0):

        self.indent().increment()
  
        loopSymbol = ('@@@@', '####')[justLoopOnce]
        if parentTreeOp:  
            # we are a 'child' looping operation
            eLog.debug('%s%s CHILD loop...', self.indent(), loopSymbol)
            self._Y_tree = parentTreeOp._Y_treeNode
        else:  
            # we are just a simple (absolute) looping operation
            eLog.debug('%s%s Simple loop...' , self.indent(), loopSymbol)

        dynoList = list()
        
        # if not '_Y_mpath' in self.__dict__:
        #    pass
        
        if not self._Y_segName:  # if not set at init time, then use eval time _Y_segName
            eLog.debug('%sTREE Seg name not set at creation, using eval time arg as seg name [%s].',
                            self.indent(), segName)
            self._Y_segName = segName  
        if not self._Y_segName:
            errMsg = 'Internal TreeMapping Error: Segment name neither set at creation nor at evaluation in TreeOp!'
            raise BEDISx_MappingError(errMsg=errMsg)
        
        # build args tuple for getloop() => like {'BOTSID':'EdiTx'}, {'BOTSID':'ShippingNotice', 'DateShipped':'20110522'}, ...
        pathContexts = self._Y_mpath.split('.')
        botsLoop = list() 

        #for pc in pathContexts:
        #    matchList = []
        #    if '=' in pc: # must match value of specified columns at this level
        #        pieces = string.split(pc,'=')
        #        pc = pieces[0]
        #        matchList = pieces[1:]
        #    botsContext = dict(BOTSID=pc)
        #    # add match info for each context level like {'BOTSID':'ShippingNotice', 'DateShipped':'20110522'}
        #    for fieldName in matchList:
        #        botsContext[fieldName] = self.contextDict[pc].__dict__[fieldName] # must match field value in matching context
        #    botsLoop.append(botsContext)
        
        # loop over each level of context, building a list of dic entries like {'BOTSID':'contextName'}    
        for pc in pathContexts:
            botsContext = dict(BOTSID=pc)
            botsLoop.append(botsContext)
        # save last values
        contextName = pc
        context = botsContext
                
        i = 0
        # for e1 in inn.getloop({'BOTSID':'EdiTx'}, {'BOTSID':'ShippingNotice', 'DateShipped':'20110522'}, {'BOTSID':'SalesOrder'}):
        self.printOpMsg(botsLoop)
        
        for node in self._Y_tree.getloop(*tuple(botsLoop)):   # loop until we are done (or once if justLoopOnce is set)            
            self._Y_treeNode = node    # save reference to current __tree node; 
                                    # will be needed to insure that child loops are in current context
            
            i += 1
            if justLoopOnce and i>1:
                break

            eLog.debug('%sTREE [%s] Loop[%s]=========================', self.indent(), self._Y_segName, i)
            dyno = DynO(__NAME=contextName)
            dynoList.append(dyno)
            
            for k in self.valueFieldsIter():
                
                if isinstance(self[k], str):  #simple get() on current value of node
                    botsGetArgs = dict()
                    botsGetArgs['BOTSID']=pc
                    botsGetArgs[pc+'__'+self[k]]=None
                    # inn.get({'BOTSID':'EdiTx'}, {'BOTSID':'ShippingNotice', 'Invoice__Plant':None})
                    childVal = node.get(botsGetArgs)
                    dyno[k] = childVal
                    # eLog.debug('%sBOTS   %s = INN.get%s -> %s',
                    #    self.indent(), k, tuple(zip(botsGetArgs.keys(), botsGetArgs.values())), childVal)
                    eLog.debug('%sTREE  .%s = \'%s\'', self.indent(), k, childVal)
                    
                else: # must be a TreeOpBase object
                    childVal = self[k]
                    # value must be recomputed
                    # self is passed to evaluate; only used by GetChildLoopsBase op objects
                    childVal._Y_segName = k
                    evaluation = childVal.evaluate(k, self)  # child loops use _Y_treeNode as their _Y_tree
                    dyno[k] = evaluation
                    if isinstance(evaluation, list):
                        eLog.debug('%sTREE [%s] End of get List', self.indent(), k)
                    else:
                        eLog.debug('%sTREE [%s] End of get Object', self.indent(), k)
                
        self.indent().decrement()
        
        if justLoopOnce: # just return the dyno for this loop
            if i:   # found one
                resultDyno = dynoList.pop()
            else:
                resultDyno = None
            del dynoList
            return resultDyno
        else: # return list of all loop dynos
            return dynoList
        
    def evaluate(self,  segName, parentTreeOp=None):
        errMsg = '%sTREE Error: Abstract GetLoopsBase.evaluate should NEVER be called directly!', (self.indent(),)
        raise BEDISx_MappingError(errMsg=errMsg)

# root of Get TreeOps tree    

class DocGetOpsTree(GetLoopsBase): 
    
    def __init__(self, rootOfTree, mpath, **kw):
        super(DocGetOpsTree, self).__init__(mpath, 'ROOT', **kw)
        self._Y_tree = rootOfTree        # treeRoot or set from _Y_parentTreeOp passed to eval()
        self._Y_treeNode = None          # set in _Y_parentTreeOp and passed to child in eval()
        self._Y_atRootNode = False
    
    def evaluate(self, globalsDict, localsDict, segName=None):
        TreeOpBase._Y_globalsDict = globalsDict
        TreeOpBase._Y_localsDict = localsDict
        if segName:
            self._Y_segName = segName
        return self.evaluateInternal(segName, parentTreeOp=None, justLoopOnce=1)
        
class GetOneLoop(GetLoopsBase): 
    
    def __init__(self, mpath=None, segName=None, **kw):
        super(GetOneLoop, self).__init__(mpath, segName, **kw)

    def evaluate(self, segName, pTreeOp=None):
        return self.evaluateInternal(segName, parentTreeOp=None, justLoopOnce=1)
    
class GetAllLoops(GetLoopsBase): 
    
    def __init__(self, mpath=None, segName=None, **kw):
        super(GetAllLoops, self).__init__(mpath, segName, **kw)

    def evaluate(self, segName, pTreeOp=None):
        return self.evaluateInternal(segName, parentTreeOp=None, justLoopOnce=0)
    
#abstract
class GetChildLoopsBase(GetLoopsBase):
    
    def __init__(self, mpath=None, segName=None, **kw):
        super(GetChildLoopsBase, self).__init__(mpath, segName, **kw)    

class GetOneChildLoop(GetChildLoopsBase):
               
    def __init__(self, mpath=None, segName=None, **kw):
        super(GetOneChildLoop, self).__init__(mpath, segName, **kw)    

    def evaluate(self, segName, parentTreeOp):
        return self.evaluateInternal(segName, parentTreeOp, justLoopOnce=1)
    
class GetAllChildLoops(GetChildLoopsBase):
               
    def __init__(self, mpath=None, segName=None, **kw):
        super(GetAllChildLoops, self).__init__(mpath, segName, **kw)    

    def evaluate(self,  segName, parentTreeOp):
        return self.evaluateInternal(segName, parentTreeOp, justLoopOnce=0)

#===============================================================================
# tree PUT operations    
#
# Traverse a tree of 'put' operations, depth first, executing BOTS outmessage.put
# operations with the value calculated at each node.  The net effect of this
# behavior results is a newly created BOTS outmessage built through successive 
# application of tree value transformation operations on an input data tree.
#===============================================================================

#abstract

class PutLoopsBase(TreeOpBase): 
    
    def __init__(self, mpath=None, segName=None, **kw):
        super(PutLoopsBase, self).__init__(mpath, segName, **kw)

    def evaluateInternal(self, segName=None, parentTreeOp=None, justLoopOnce=0):  
#        if '_Y_IF' in self or '_Y_USES' in self:
#            eLog.error('Internal error, processing instruction found in __tree at eval: Seg \'%s\' of type %s!' % 
#                        (segName, self.__class__.__name__))
        self._Y_parentTreeOp = parentTreeOp    # always remember our parent
        
        if not self._Y_segName:  # if not set at init time, then use eval time _Y_segName
            eLog.debug('%sTREE Seg name not set at creation, using eval time arg as seg name [%s].',
                            self.indent(), segName)
            self._Y_segName = segName  
        if not self._Y_segName:
            errMsg = 'Internal TreeMapping Error: Segment name neither set at creation nor at evaluation in TreeOp!'
            raise BEDISx_MappingError(errMsg=errMsg)
                
        if parentTreeOp and self.atRootNode():
            self._Y_mpath = parentTreeOp._Y_mpath+'.'+segName
        elif parentTreeOp:
            self._Y_mpath = parentTreeOp._Y_segName+'.'+segName
        else:
            self._Y_mpath = segName
        
        self.indent().increment()
        loopSymbol = ('@@@@', '####')[justLoopOnce]
        loopOrSeg =  ('Loop', 'Segment')[justLoopOnce]
        
        if not justLoopOnce:
            self._Y_resultsTree._Y_LIST = True
        
        if parentTreeOp:  
            # we are a 'child' looping operation
            # eLog.debug('%s%sChild %s...' % (self.indent(), loopSymbol, loopOrSeg))
            self._Y_tree = parentTreeOp._Y_treeNode
        else:  
            # we are just a simple (absolute) looping operation
            # eLog.debug('%s%sSimple %s...' % (self.indent(), loopSymbol, loopOrSeg))
            # top level TreeOp, so _Y_tree was set in __init__
            pass
        
        # build args tuple for putloop() => like {{'BOTSID':'EdiTx'}, {'BOTSID':'ST'}, {'BOTSID':'BSN'})
        pathContexts = self._Y_mpath.split('.')
        botsLoop = list()
        
        # loop over each level of context, building a list of dic entries like {'BOTSID':'contextName'}    
        for pc in pathContexts:
            botsContextSpec = dict(BOTSID=pc)
            botsLoop.append(botsContextSpec)

        # save last values; they specify our current BOTS 'put' context (the data segment we are populating)  
        treeContextID = pc
        treeContext = dict(BOTSID=pc)
                
        if self.atRootNode():     
            # we do not need to loop since _Y_mpath is absolute (or specifically at the root of the _Y_tree)
            # eLog.debug('%sSegment %s ..........................', self.indent(), treeContextID)
            self.processFields(treeContext, self._Y_tree, self._Y_resultsTree)
        else:
            i = 0
            
            # for putloop({'BOTSID':'ST'}, {'BOTSID':'BSN'}):
            self.printOpMsg(botsLoop)
            node = self._Y_tree.putloop(*botsLoop)
            self._Y_treeNode = node
            
            if not justLoopOnce:
                eLog.debug('%sTREE Segment %s[%s] .........................', self.indent(), treeContextID, i)
            self.processFields(treeContext, node, self._Y_resultsTree)
            
        self.indent().decrement()
        return self._Y_resultsTree
            
    def processFields(self, treeContext, treeNode, resultsTree):
        # first perform evaluations and assign constants
        for fieldName in self.valueFieldsIter():
            valueSpec = self[fieldName]
            fieldVal = None                        # assigned below
            
            # a string specifying a valid sequence of Python statements, (i.e a 'scriptlet') that starts with a '@'
            if isinstance(valueSpec, str) and valueSpec[0]=='@':
                  
                # For example, if valueSpec is a string like... 
                #
                #     '@if: me.happy() then: me.smile()'
                #
                # Assuming that 'me' is a variable referencing an instance of some class that implements 
                # the methods 'happy(self)' and 'smile(self)', this code can evaluated and, if valid, 
                # will return the result object from evaluating the last Python statement executed.
                # Otherwise, an exception will be thrown.
                 
                # ex: fieldname = 'BSN02'
                # ex: valueSpec = "@600 + 60 + 6"
                # execute the Python scriptlet
                scriptlet = valueSpec[1:]       
                try:
                    fieldVal = eval(scriptlet, TreeOpBase._Y_globalsDict, TreeOpBase._Y_localsDict)
                    eLog.debug('%sTREE  .%s  = \'%s\'  <-- eval(%s)', self.indent(), fieldName, fieldVal, scriptlet)
                    # ex: fieldVal = '666'
                    self.setOutFieldValueInContext(fieldName, fieldVal, treeContext, treeNode, resultsTree)
                except:
                    errMsg = '%sTREE ======>INTERNAL ERROR during eval(%s) for field [%s]\n%s' % (
                        self.indent(), scriptlet, fieldName, botslib.txtexc())
                    raise BEDISx_MappingError(errMsg=errMsg)
                
            # a literal or constant value of a variable    
            elif not isinstance(valueSpec, TreeOpBase):
                fieldVal = valueSpec     # just use the passed value
                eLog.debug('%sTREE  .%s = \'%s\'', self.indent(), fieldName, fieldVal)
                self.setOutFieldValueInContext(fieldName, fieldVal, treeContext, treeNode, resultsTree)
            
        # then evaluate subtrees    
        for fieldName in self.valueFieldsIter():
            valueSpec = self[fieldName]

            # a TreeOp put expression; no result to store
            if isinstance(valueSpec, TreeOpBase):
                valueSpec._Y_segName = fieldName
                if valueSpec.satisfiesPreconditions():    
                    eLog.debug('%sTREE [%s] evaluating segment values... ', self.indent(), fieldName)
                    # 'child' loops will use my self._Y_treeNode as their 'local' _Y_tree root
                    valueSpec.evaluate(fieldName, self)
                    resultsTree[fieldName] = valueSpec.getResultsTree()
                else:
                    resultsTree[fieldName] = None
        
        # In the outgoing X12 outmessage document, the current 'BSN' segment would generate a line that looks
        # like this (using the sample field values shown): BSN*<BSN01>*666*<BSN03>
        
        return resultsTree
        
    def setOutFieldValueInContext(self, fieldName, fieldValue, treeContext, treeNode, resultsTree):
        if fieldValue:  # DO NOT WRITE EMPTY VALUES
            # store the result field value at the current 'level' of the _Y_tree, keyed by the fieldName
            # ex: node.put({'BOTSID':'BSN', 'BSN02':'666'})
            botsPutArgs = treeContext.copy()                  # {'BOTSID':'<current segment context>'}
            botsPutArgs[fieldName] = fieldValue               # {'BOTSID':'<current segment context>', 'BSN02':'666'}
            
            # eLog.debug('%sBOTS   OUT.put(%s)', self.indent(), botsPutArgs)
            treeNode.put(botsPutArgs)
            
            # update our internal dictionary value for this field
            resultsTree[fieldName] = fieldValue

    def evaluate(self, segName, parentTreeOp=None):
        errMsg = '%sTREE ======>INTERNAL ERROR PutLoopsBase.evaluate should NEVER be called directly!' % (self.indent(),)
        raise BEDISx_MappingError(errMsg=errMsg)
    
    def atRootNode(self):
        return False
   
    def satisfiesPreconditions(self):      
        return True
    
# root of 'put' TreeOps _Y_tree;  This is only node w/o a _Y_parentTreeOp set at eval time    
class OutDocTreeMap(PutLoopsBase): 
    
    def __init__(self, rootOfTree, segName, **kw):
        # note: no __mpath atthe root
        super(OutDocTreeMap, self).__init__(None, segName, **kw)
        self._Y_tree = rootOfTree 
        self._Y_treeNode = rootOfTree
        
    def evaluate(self, globalsDict, localsDict, segName=None):
        TreeOpBase._Y_globalsDict = globalsDict
        TreeOpBase._Y_localsDict = localsDict
        if segName:
            self._Y_segName = segName
        self.setResultsTree(self.evaluateInternal(self._Y_segName, parentTreeOp=None, justLoopOnce=1))
    
    def atRootNode(self):
        return True

#abstract
class PutChildLoopsBase(PutLoopsBase):
    
    def __init__(self, mpath=None, segName=None, **kw):
        super(PutLoopsBase, self).__init__(mpath, segName, **kw)


class Seg(PutChildLoopsBase):
    def __init__(self, **kw):
        super(Seg, self).__init__(None, None, **kw)

    def evaluate(self, segName, parentTreeOp):
        self.setResultsTree(self.evaluateInternal(segName, parentTreeOp, justLoopOnce=1))

    def satisfiesPreconditions(self):
        # if _Y_IF was specified in KWs, then we need to evaluate the string 
        okToGen = True
        if not '_Y_IF' in self.__dict__:
            pass
        if ('_Y_IF' in self.__dict__) and isinstance(self._Y_IF, str):
            if self._Y_IF[0]=='@':      # evaluate scriptlet
                try:
                    okToGen = eval(self._Y_IF[1:], TreeOpBase._Y_globalsDict, TreeOpBase._Y_localsDict)
                    eLog.debug('%sTREE [%s] Checking _Y_IF precondition: eval(%s)',
                        self.indent(), self._Y_segName, self._Y_IF)
                except:
                    errMsg = '%sTREE ======>INTERNAL ERROR during eval(%s) of _Y_IF condition for seg [%s]\n%s' % (
                        self.indent(), self._Y_IF, self._Y_segName, botslib.txtexc())
                    raise BEDISx_MappingError(errMsg=errMsg)
            else:
                okToGen = self._Y_IF    # assume it's a constant value
            
        if okToGen:
            # eLog.debug('%sTREE [%s] Passed. Segment will be generated.', self.indent(), self._Y_segName)
            return True
        else:
            eLog.debug('%sTREE [%s] Failed. Segment will NOT be generated.', self.indent(), self._Y_segName)
            return False
    
class SegList(PutChildLoopsBase):
    
    def __init__(self, **kw):
        super(SegList, self).__init__(None, None, **kw)
    
    def setSegsUsed(self, segList):
        self._Y_segList = segList
        
    def getSegsUsed(self):
        return self._Y_segList
    
    def evaluate(self, segName, parentTreeOp):
        # remove processing instructions at time of first eval
        if not ('_Y_segList' in self.__dict__):
            if '_Y_USES' in self.__dict__:
                segsUsed = self.__dict__.pop('_Y_USES', None)
                if segsUsed:
                    self._Y_segList = ['_'+tag for tag in segsUsed.split(',')]
                else:
                    self._Y_segList = list()  # empty
            else:
                errMsg = '%sTREE ======>INTERNAL ERROR: _Y_USES must be specified for SegList %s!' % (
                    self.indent(), segName)
                raise BEDISx_MappingError(errMsg=errMsg)
            
        segList = self.getSegsUsed()
        eLog.debug('%s@@@@ [%s] Looping: for all value segs in %s...', self.indent(), segName, segList)
        
        resultsTree = DynO()
        resultsTree._Y_LIST = True
        
        old_self = self.copy()   # save my dict of branches and leaves (values for all defined segs in this loop)
        for segID in segList:
            
            segDef = old_self.get(segID) or Seg()   # empty dict if None
            if segDef:
                segDef._Y_segName = segName # set the segName
            #else:
            #    errMsg = '%sTREE ======>INTERNAL ERROR: Seg ID named %s not found in SegList %s!' % (
            #        self.indent(), segID, segName)
            #    raise BEDISx_MappingError(errMsg=errMsg)
                
            if segDef.satisfiesPreconditions():
                self.clear()         # clear my segs to make room for new ones
                self.update(segDef)  # I don't feel like myself today ;-(
                 
                eLog.debug('%s#### [%s] Using values in %s', self.indent(), segName, segID)
                resultsTree[segID] = self.evaluateInternal(segName, parentTreeOp, justLoopOnce=1)
                self.setSegName(segName)
                self.setName(segName)
            else:
                pass  # do not add an entry for segIDs that fail preconditions
            
        self.clear()                # clear old segs and replace my original ones
        self.update(old_self)       # ahhh, I feel like my old self again ;-)

        self.setResultsTree(resultsTree)

class ForLoop(PutChildLoopsBase):
               
    def __init__(self, iterVar, iterGen, **kw):
        super(ForLoop, self).__init__(None, None, **kw)
        self._Y_iVar = iterVar             # iteration variable name
        self._Y_iGen = iterGen             # code to generate the iterator

    def evaluate(self, segName, parentTreeOp):
        self._Y_LIST = True
        eLog.debug('%s@@@@ [%s] Looping: for %s in %s: evaluating...', self.indent(), segName, self._Y_iVar, self._Y_iGen)
        iteratorCode = '%s', self._Y_iGen
        iterated = None
        resultsTree = DynO()
        resultsTree._Y_LIST = True
        try:
            iterated = eval(self._Y_iGen, TreeOpBase._Y_globalsDict, TreeOpBase._Y_localsDict)
        except:
            errMsg = '%sTREE ======>INTERNAL ERROR evaluating iterated list: [%s] in seg [%s]' % (
                self.indent(), self._Y_iGen, segName)
            eLog.error(errMsg)
            raise BEDISx_MappingError(errMsg=errMsg)
        i = 0
        for itValue in iterated:
            i += 1
            if isinstance(itValue, DynO):
                itID = itValue.get('_Y_ID', str(i))  # if iterating objects, each obj must supply a unique _Y_ID value 
            else:
                itID = itValue
            eLog.debug('%s#### [%s] Seg loop %s.next()', self.indent(), segName, self._Y_iVar)
            TreeOpBase._Y_localsDict[self._Y_iVar] = itValue    # update value of iterator var in _Y_localsDict
            resultsTree['_'+itID] = copy.deepcopy(self.evaluateInternal(segName, parentTreeOp, justLoopOnce=1))    
            resultsTree['_'+itID]._Y_NAME = '_'+itID 
        self.setResultsTree(resultsTree)
            
class ReRootAtOutSeg(PutLoopsBase):

    def __init__(self, parentTreeOpSegName, realTreeOp, **kw):
        super(ReRootAtOutSeg, self).__init__(None, None, **realTreeOp)
        self._Y_parentTreeOpSegName = parentTreeOpSegName
        self._Y_realTreeOp = realTreeOp
        
    def evaluate(self, segName, obsoleteParentTreeOp):
        
        # at first eval we need to refresh children of __realTreeOp from internal dict (may have changed)
        if not ('_Y_childrenHaveBeenRefreshed' in self.__dict__):
            self._Y_realTreeOp.clear()
            self._Y_realTreeOp.update(self)    # replace _Y_realTreeOp's children with my dict contents
            self._Y_childrenHaveBeenRefreshed = True
        
        # find new _Y_parentTreeOp by searching up _Y_parentTreeOp nodes
        # until we find one with _Y_segName matching _Y_parentTreeOpSegName
        parentTreeOp = obsoleteParentTreeOp
        self._Y_segName = segName
        
        if not ('_Y_parentTreeOp' in self.__dict__):  # initialize this value the first time
            while parentTreeOp and ('_Y_segName' in parentTreeOp.__dict__) and not parentTreeOp._Y_segName==self._Y_parentTreeOpSegName:
                parentTreeOp = parentTreeOp._Y_parentTreeOp
                eLog.debug('%sTREE Looking up tree for new parent seg=\'%s\': Checking seg [%s]',
                    self.indent(), segName, parentTreeOp._Y_segName)
        
            if parentTreeOp and ('_Y_segName' in parentTreeOp.__dict__):
                # found it, so reassign 'our' parent to this new root node
                self._Y_parentTreeOp = parentTreeOp
            else:
                errMsg = '%sTREE ======>INTERNAL ERROR, could not locate parent subtree seg [%s] in seg [%s]' % (
                     self.indent(), self._Y_parentTreeOpSegName, self._Y_segName)
                eLog.error(errMsg)
                raise BEDISx_MappingError(errMsg=errMsg)
         
        # our asProxyForTreeOp 'child' is the really the segment named _Y_segName, 
        # we are just impersonating it for the moment.  This is where we evaluate the real treeOp
        self._Y_realTreeOp.evaluate(segName, self._Y_parentTreeOp)    # our parent becomes his (we are invisible parent node)
        
        # need to set our results using results of the real treeOp evelauation
        self.setResultsTree(self._Y_realTreeOp.getResultsTree())