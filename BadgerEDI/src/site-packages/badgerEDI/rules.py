
'''
Content Tree Validation Module

@author: jknaus
'''

from badgerEDI.bedislib import *
from badgerEDI.db import *
from badgerEDI.ediutil import *

from badgerEDI.treeops import *

from badgerEDI.indentation import Indentation

DEBUG_PATH_STACK = False
DEBUG_SCOPE_MATCHING = False
DEBUG_SCOPE_TRACING = False
DEBUG_RULE_TRACING = False

class SelfFormattingList(list):
    
    def __str__(self):
        if len(self):
            return '|'.join(self)
        else:
            return ''
        
class Rule(object):
    
    def __init__(self, *argsList, **fieldDict):
        self.vlist = argsList
    
    def applyTo(self, tree, vLog):
        return False        # abstract 
    
    def __repr__(self):
        return '%s%s' % (self.__class__.__name__, self.vlist)
    
class RMustBe(Rule):

    def applyTo(self, tree, vLog, vEng):
        path = vEng.getCurrPath()
        if DEBUG_RULE_TRACING:
            vLog.debug('%s[Rule] %s.RMustBe%s', vEng.indent, path, self.vlist)
        if not tree in self.vlist:
            parentSegPath = vEng.getParentPath()
            vEng.error(vLog, 'Value of field\n  %s,\ncurrently valued \'%s\', must be set to \'%s\' in segment\n  %s\nPlease make sure that the field value is set to \'%s\' to correct this error.',
                vEng.asTxt(path), tree, str(self.vlist[0]), vEng.asTxt(parentSegPath), str(self.vlist[0]))
            return False
        else:
            return True
    
class RValueIn(Rule):

    def applyTo(self, tree, vLog, vEng):
        path = vEng.getCurrPath()
        if DEBUG_RULE_TRACING:
            vLog.debug('%s[Rule] %s.RValueIn%s', vEng.indent, path, self.vlist)
        if not tree in self.vlist:
            parentSegPath = vEng.getParentPath()
            vEng.error(vLog, 'Value of field\n  %s,\ncurrently valued \'%s\', must be one of the following allowed values:\n  %s\nin segment\n  %s\nPlease choose a new value for this field from the list of allowed values.',
                vEng.asTxt(path), tree, str(self.vlist).replace(',)', ')', -1).replace(')', '', -1).replace('(', '', 1), vEng.asTxt(parentSegPath))
            return False
        else:
            return True
        
class RCond(Rule):

    def applyTo(self, seg, vLog, vEng):
        path = vEng.getCurrPath()
        if DEBUG_RULE_TRACING:
            vLog.debug('%s[Rule] %s.RCond%s', vEng.indent, path, self.vlist)
        condFieldName = self.vlist[0]
        condVal = seg.get(condFieldName, None)
        if condVal:
            # use '?' as separator for named segments
            if condFieldName.startswith('_'):
                cfSepChar = '?'
            else:
                cfSepChar = '.'
            for fieldName in self.vlist[1:]:
                if not seg.get(fieldName, None):
                    if fieldName.startswith('_'):
                        fSepChar = '?'
                    else:
                        fSepChar = '.'
                    vEng.error(vLog, 
                        'If value of field\n  %s\nis specified, then a value for field\n'+
                        '  %s\nis also required within the segment defining\n  %s\nPlease add a value for the missing field.',
                        vEng.asTxt(path+cfSepChar+condFieldName), vEng.asTxt(path+fSepChar+fieldName), vEng.asTxt(path))
        else:
            return True
    
class RAtomic(Rule):

    def applyTo(self, seg, vLog, vEng):
        path = vEng.getCurrPath()
        if DEBUG_RULE_TRACING:
            vLog.debug('%s[Rule] %s.RAtomic%s', vEng.indent, path, self.vlist)
        # either all or none of the fields must be specified in the seg
        foundCnt = 0
        missingList = list()
        for field in self.vlist:
            if seg.get(field, None):
                foundCnt += 1
            else:
                missingList.append(field)
        if foundCnt==0 or foundCnt==len(self.vlist): 
            return True
        else:
            vEng.error(vLog, 
                'If any of the following values%sare specified in segment\n'+
                '  %s\nthen all remaining values must be specified as well.\n'+
                'Values for the following fields have not been specified:%sPlease supply the missing field values.', 
                vEng.tupleAsTxt(self.vlist, path), vEng.asTxt(path), vEng.tupleAsTxt(missingList, path))
            return False 
    

class ROneOf(Rule):

    def applyTo(self, seg, vLog, vEng):
        path = vEng.getCurrPath()
        if DEBUG_RULE_TRACING:
            vLog.debug('%s[Rule] %s.ROneOf%s', vEng.indent, path, self.vlist)
        for field in self.vlist:
            if seg.get(field, None):
                return True     # found at least one matching field specified in the seg, short circuit exit
        vEng.error(vLog, 'At least one of the following values%smust be specified in segment\n  %s\nPlease specify a value for at least one of the required fields.', 
            vEng.tupleAsTxt(self.vlist, path), vEng.asTxt(path))
        return False
    

class RReqs(Rule):

    def applyTo(self, seg, vLog, vEng):
        path = vEng.getCurrPath()
        if DEBUG_RULE_TRACING:
            vLog.debug('%s[Rule] %s.RReqs%s', vEng.indent, path, self.vlist)
        normPath = path
        # checks all fields in list, even if an error is encountered along the way
        allOK = True
        for fieldSpec in self.vlist:
            ok = True
            subs = fieldSpec.split('[')
            fName = subs[0]  # first part will always be the field name
            if DEBUG_RULE_TRACING:
                vLog.debug('%s[Rule] %s is a required field in segment %s', 
                   vEng.indent, vEng.getFieldAsTxt(path+'.'+fName), vEng.asTxt(path))
            exactCnt = 0
            lowCnt = 0
            highCnt = 0
            size = 0
            if len(subs) > 1:
                fRange = subs[1]
                if not fRange.endswith(']'):
                    vEng.error(vLog, 
                        "Internal: Improper RReqs field spec format \'%s\'. "+
                        "Required field may only be specified in one of these forms: "+
                        "'field', 'field[n]', or 'field[n-m]'.", 
                        fieldSpec)
                    ok = False
                else:
                    fRange = fRange[:-1]
                    if '-' in fRange:
                        (lowCnt, highCnt) = fRange.split('-')
                        lowCnt = int(lowCnt)
                        highCnt = int(highCnt)
                        if DEBUG_RULE_TRACING:
                            vLog.debug('%s[Rule] Field %s is required to appear between %s and %s times in segment %s.', 
                                vEng.indent, vEng.getFieldAsTxt(path+'.'+fName), lowCnt, highCnt, vEng.asTxt(path))
                    else:
                        exactCnt = int(fRange)
                        if DEBUG_RULE_TRACING:
                            vLog.debug('%s[Rule] Field %s is required to appear exactly %s times in segment %s.', 
                                vEng.indent, vEng.getFieldAsTxt(path+'.'+fName), exactCnt, vEng.asTxt(path))
            fValue = seg.get(fName, None)
            if ok and fValue:
                # vLog.debug('FIELD %s=%s', fName, fValue)
                if isinstance(fValue, DynO):        # branch node in tree: if isList, then size of list, else 1
                    size = fValue.size()
                elif isinstance(fValue, str) or isinstance(fValue, int) or isinstance(fValue, float):  # scalar: size is 1
                    size = 1
                else:
                    vEng.error(vLog, 'Internal: Cannot validate value. Value of %s is an unsupported type %s!', 
                        vEng.asTxt(path+'.'+fName), fValue.__class__)
                    ok = False
                # vLog.debug('FIELD SIZE=%s', size)
                if exactCnt and size != exactCnt:
                    vEng.error(vLog, 
                        'Value count not in range. Value of\n  %s,\nwhich appears %s time(s), '+
                        'is required to appear exactly %s time(s) in segment\n  %s\nPlease correct this error.', 
                        vEng.asTxt(path+'.'+fName), size, exactCnt, vEng.asTxt(path))
                    ok = False
                elif lowCnt and highCnt and not (lowCnt <= size <= highCnt):
                    vEng.error(vLog, 
                        'Value count not in range. Value of\n  %s,\nwhich appears %s time(s), '+
                        'is required to appear from %s to %s time(s) in segment\n  %s\nPlease correct this error.', 
                        vEng.asTxt(path+'.'+fName), size, lowCnt, highCnt, vEng.asTxt(path))
                    ok = False
                # this field is required and it did not fail any count checks, so still OK
                    
            else: # is empty string, None, or unspecified
                segIDKey = None
                if fName.startswith('_'):
                    fSep = '.?'
                    segIDKey = path[-1]
                    vEng.pushNextStep(fName) 
                else:
                    fSep = '.'
                vEng.error(vLog, 'Required field value\n  %s\nis missing in segment\n  %s\nPlease add a value for this required field.', 
                    vEng.asTxt(path+fSep+fName), vEng.asTxt(path))   # no value found
                if segIDKey:
                    vEng.popLastStep()
                ok = False
                
            allOk = allOK and ok
            
        return allOK


class ValidationEngine(object):

    def __init__(self, rulesList, fieldDict, segIDFormats=dict()):
        self.indent = Indentation(' '*5, '>')
        self.fieldDict = fieldDict  # for lookup of field description text
        self.segIDFormats = segIDFormats
        self.rules = dict()
        for rRuleSpec in rulesList:
            # collect list of rules for each regex key
            rScope, rRule = rRuleSpec
            if rScope in self.rules:
                self.rules[rScope].append(rRule)
            else:
                self.rules[rScope] = [rRule]
                
    def initializeValidation(self, vLog):
        self.vLog = vLog
        self.errors = 0
        self.errorList = list()      # list of varg lists passed to log.error()
        self.path = list()           # current segID scope; seg/scalar name pushed at each step
        self.currPathSegIDs = dict() # dict of values of segment qualifiers encountered along current path
    
    def finalizeValidation(self):    
        self.vLog = None

    def error(self, vLog, *vargs):
        self.errors += 1
        self.errorList.append(vargs)
        # vLog.error('\n'+vargs[0], *vargs[1:])    
        vLog.error(*vargs)    
        
    def pushNextStep(self, step):
        if step.startswith('_') and self.path:   
            # add step (seg ID minus the prefix) to dict of curr path seg ID values, key is val of prior step
            segIDKey = self.path[-1]
            newStep = '?'+step
            segIDFormat = self.segIDFormats.get(segIDKey)
            if segIDFormat and isinstance(segIDFormat, list):
                if not segIDKey in self.currPathSegIDs:  # if not there already
                    self.currPathSegIDs[segIDKey] = SelfFormattingList()
                self.currPathSegIDs[segIDKey].append(self.asSegIDTxt(segIDKey, step[1:]).split('|', -1)[-1])
                if DEBUG_PATH_STACK:
                    self.vLog.debug('%sPath |###PUSH< Pushing %s onto end of segIDs[%s]', self.indent, self.currPathSegIDs[segIDKey][-1], segIDKey)        
                    self.vLog.debug('%sPath |###PUSH< pushing %s', self.indent, newStep)        
            else:
                self.currPathSegIDs[segIDKey] = self.asSegIDTxt(segIDKey, step[1:])  # so, for example, HISTORY._6 becomes '6'
                if DEBUG_PATH_STACK:
                    self.vLog.debug('%sPath |###PUSH< setting segIDs[%s]= %s', self.indent, segIDKey, self.currPathSegIDs[segIDKey])        
                    self.vLog.debug('%sPath |###PUSH< pushing %s', self.indent, newStep)        
            self.path.append(newStep)
        else:
            if DEBUG_PATH_STACK:
                self.vLog.debug('%sPath |###PUSH< pushing %s', self.indent, step)        
            self.path.append(step)
        if DEBUG_PATH_STACK:
            self.vLog.debug('%sPath |###PUSH> [%s]', self.indent, self.getCurrPath())
        pass
        
    def popLastStep(self):
        if DEBUG_PATH_STACK:
            self.vLog.debug('%sPath |####POP< [%s]', self.indent, self.getCurrPath())
        step = self.path.pop()
        if DEBUG_PATH_STACK:
            self.vLog.debug('%sPath |####POP< popped %s', self.indent, step)        
        if '?' in step and self.path:
            segIDKey = self.path[-1]
            segIDFormat = self.segIDFormats.get(segIDKey)
            if segIDFormat and isinstance(segIDFormat, list):
                if DEBUG_PATH_STACK:
                    self.vLog.debug('%sPath |####POP< Popping last element off of list segIDs[%s]', self.indent, segIDKey)        
                self.currPathSegIDs[segIDKey].pop()  # pop last one off the end of the lists
            else:
                if DEBUG_PATH_STACK:
                    self.vLog.debug('%sPath |####POP< Clearing value of segIDs[%s]', self.indent, segIDKey)        
                self.currPathSegIDs[segIDKey] = None
        pass
    
    def getCurrPath(self):
        return '.'.join(self.path)

    def getParentPath(self):
        return len(self.path)>1 and '.'.join(self.path[:-1])
        
    def generalizeQualifiedPathNames(self, qPathName):
        gPathName = qPathName
        tokStart = gPathName.find('?')
        gPathList = list([gPathName])
        while tokStart >= 0:   # found a '?', else finished converting
            # find end of next ?_xxxxx token (will be a '.' or end of string (-1))
            tokEnd = gPathName.find('.', tokStart)
            # replace with '*'
            if tokEnd >= 0:
                gPathName = gPathName[:tokStart] + '*' + gPathName[tokEnd:]
            else:
                gPathName = gPathName[:tokStart] + '*'
            # add to list
            gPathList.append(gPathName)
            tokStart = gPathName.find('?', tokStart)
        return gPathList
    
    def getMostNarrowlyApplicableRulesScopeForPath(self, qPathNameIn):
        if qPathNameIn.find('?') == -1:
            # no qualifiers in path, so just do a simple lookup
            if DEBUG_SCOPE_MATCHING:
                self.vLog.debug('%sLooking for rules matching: %s', self.indent, qPathNameIn)        
            if qPathNameIn in self.rules:
                return qPathNameIn
            else: 
                return None
        else:
            qPathName = qPathNameIn.replace('.?','?')
            # search for text by qualified path name
            if DEBUG_SCOPE_MATCHING:
                self.vLog.debug('%sChecking scope: %s', self.indent, qPathName)   
            if qPathName in self.rules:
                return qPathName
            else:
                # search for text using progressively generalized names for matching
                genPathScopesList = self.generalizeQualifiedPathNames(qPathName)
                for genPathScope in genPathScopesList:
                    if DEBUG_SCOPE_MATCHING:
                        self.vLog.debug('%sChecking scope: %s', self.indent, genPathScope)   
                    if genPathScope in self.rules:
                        return genPathScope  # break out of loop and return matching pathScope
                return None    # no rules found at any level of pathScope generalization

    def getFieldAsTxt(self, fName):
        if fName.find('?') == -1:
            # no qualifiers in path, so just do a simple lookup
            fNameTxt = self.getFieldName(fName) 
            if fNameTxt != fName:    # if found
                return self.formatWithSegIDs(fNameTxt)
        else:
            # search for text by qualified path name
            fNameTxt = self.getFieldName(fName) 
            if fNameTxt == fName:  # if qualified name not found
                # search for text by progressively generalized names
                genPathNamesList = self.generalizeQualifiedPathNames(fName)
                for genFieldName in genPathNamesList:
                    fNameTxt = self.getFieldName(genFieldName)
                    if fNameTxt and fNameTxt != genFieldName:   # if text for generalized field name found
                        return self.formatWithSegIDs(fNameTxt)  # break out of loop and return text string
            else:
                return self.formatWithSegIDs(fNameTxt)
        return fName    # not found at any level of generalization
        
    def getFieldName(self, fName):
        # find most specific field name def that applies
        # search for text by progressively generalized names
        if not '?' in fName and not '*' in fName:
            # simple lookup
            return self.fieldDict.get(fName, fName)   # return original if not found
        else:
            fNamePath = fName.replace('.?','?').replace('.*','*')
            genPathNamesList = self.generalizeQualifiedPathNames(fNamePath)
            if fNamePath.startswith('ST.CAD'):
                pass
            for genFieldName in genPathNamesList:
                if DEBUG_SCOPE_MATCHING:
                    self.vLog.debug('%sChecking field name scope: %s', self.indent, genFieldName)   
                if genFieldName in self.fieldDict:
                    return self.fieldDict[genFieldName]
            # return untranslated name if not found in field name dict
            return fName
            
    def asTxt(self, fName, segSubDict=None):
        if isinstance(fName, tuple):
            return self.tupleAsTxt(fName)
        else:
            fNameTxt = self.getFieldAsTxt(fName)
            return fNameTxt
        
    def formatWithSegIDs(self, fieldFormatStr):
        try:
            return "'%s'" % fieldFormatStr.format(**self.currPathSegIDs)
        except:
            raise BEDISx_MappingError(errMsg=botslib.txtexc())
        
    def asSegIDTxt(self, segName, segID):
            if segName in self.segIDFormats:    # like 'staff member #3'
                segIDFormat = self.segIDFormats[segName]
                if isinstance(segIDFormat, dict):
                    segIDFormatString = segIDFormat.get(segID,'['+segName+'?_'+segID+']')  # get custom format string
                    segOrd = '<N/A>'                    
                elif isinstance(segIDFormat, list):
                    segIDFormatString = segIDFormat[len(self.currPathSegIDs[segName] or list())]
                else:   # just a string
                    segIDFormatString = segIDFormat
                if segID.isdigit():
                    segOrd = intToOrdinal(int(segID))    # like 5th, 3rd, etc
                else:
                    segOrd = '<N/A>'
                keyDict = {'segID':segID, 'segOrd':segOrd, 'segName':segName}
                segIDString = segIDFormatString.format(**keyDict)
                if isinstance(segIDFormat, list):
                    segIDStringList = self.currPathSegIDs[segName][:]
                    segIDStringList.append(segIDString)
                    segIDString = '|'.join(segIDStringList)
            elif segID.isdigit():   # like '3rd STAFF entry'
                segIDString = '[%s %s entry]' % (intToOrdinal(int(segID)), segName)
            else:                               # like 'STAFF?_3'
                segIDString = '['+segName+'?_'+segID+']'
            return segIDString
        
    def tupleAsTxt(self, fNameTuple, path=''):
        fTxtList = list()
        fSepChar = ''
        for fName in fNameTuple:
            if path:
                if fName.startswith('_'):
                    fSepChar = '?'
                else:
                    fSepChar = '.'
            fSegIDName = fName.startswith('_') and fName[1:] 
            if fSegIDName:
                # don't push step if already the last step on current path
                if self.path and fSegIDName == self.path[-1]:
                    fSegIDName = None
                else:
                    self.pushNextStep(fSegIDName)
            fTxtList.append(self.asTxt(path+fSepChar+fName))
            if fSegIDName: 
                self.popLastStep()
        return '\n  '+(',\n  '.join(fTxtList))+'\n'
                
    def validate(self, tree, vLog):
        self.initializeValidation(vLog)
        self._validate(tree, vLog)
        # SAVE FOR DEBUGGING 
        #if self.errors:
        #   vLog.info('\n\nThe following %s errors were discovered during content validation:', self.errors)
        #   for errorArgs in self.errorList:
        #       # vLog.info('\n'+errorArgs[0], *errorArgs[1:])
        #       vLog.error(*errorArgs)    
        self.finalizeValidation()        
        return not self.errors
        
    def _validate(self, currTreeNode, vLog, attrName=''):
        self.indent.increment()
        treeOrLeafNode = currTreeNode
        if treeOrLeafNode:
            #
            # validate list node
            if isinstance(treeOrLeafNode, DynO) and treeOrLeafNode.isListNode():
                listNode = treeOrLeafNode
                nextStepID = treeOrLeafNode.getName()
                self.pushNextStep(nextStepID)                
                vLog.debug('%sChecking elements within list node %s...', self.indent, nextStepID)
                
                qPath = self.getCurrPath()
                mSegScope = self.getMostNarrowlyApplicableRulesScopeForPath(qPath)      
                rulesToApply = None
                if mSegScope:   # if not None
                    if DEBUG_SCOPE_TRACING:
                        vLog.debug('%sUsing segment level rules scoped to segment \'%s\'.', self.indent, mSegScope)
                    rulesToApply = self.rules[mSegScope]
                     # apply rules to the seg at current node in tree
                    for ruleToApply in rulesToApply:
                        ruleToApply.applyTo(listNode, vLog, self)
                else:
                    if DEBUG_SCOPE_TRACING:
                        vLog.debug('%sNo rules applicable to list segment \'%s.\'', self.indent, qPath)
                    pass

#                mSegScope = self.getCurrPath()          # matches seg level rules like 'XXX.YYY.SEGX'
#                # first, look for 'segment' level rules to apply
#                if mSegScope in self.rules:
#                    if DEBUG_SCOPE_TRACING:
#                        vLog.debug('%sUsing segment level rules scoped to \'%s\'', self.indent, mSegScope)
#                    # apply seg rules to values of current node in tree (list node)
#                    # these usually specify whether certain segs are required or not, conditions, etc
#                    for rule in self.rules[mSegScope]:
#                        rule.applyTo(listNode, vLog, self)
                        
                # now validate segments within the list
                for childSegID, childSegNode in [(k, listNode[k]) for k in listNode.valueFieldsIter()]:
                    self.indent.increment()
                    # validate listNode children
                    if childSegID.startswith('_'):   # id's for all entries in a list node must begin with '_'
                        # validate as list item treeNode 
                        vLog.debug('%sChecking list segment item named \'%s\'', self.indent, childSegID)
                        self.pushNextStep(childSegID)  # add as next step in the path
                        # determine whether to use use 'name scoped' or 'fully scoped' rule set for the segment
                        # note: rules with a name specific scope (mScope= 'SEGX?_XY'), if present, 
                        # will override fully scoped rules (mScope= 'SEGX*') defined for that type of segment 
                        qPath = self.getCurrPath()
                        mSegScope = self.getMostNarrowlyApplicableRulesScopeForPath(qPath)      
                        rulesToApply = None
                        if mSegScope:   # if not None
                            if DEBUG_SCOPE_TRACING:
                                vLog.debug('%sUsing rules scoped to list item segment \'%s\'.', self.indent, mSegScope)
                            rulesToApply = self.rules[mSegScope]
                             # apply rules to segs at current node in tree
                            for ruleToApply in rulesToApply:
                                ruleToApply.applyTo(childSegNode, vLog, self)
                        else:
                            if DEBUG_SCOPE_TRACING:
                                vLog.debug('%sNo list segment rules applicable to child node \'%s.\'', self.indent, qPath)
                            pass
                        self._validateChildren(childSegNode, vLog)
                        self.popLastStep()  # pop last step off the path
                    else:
                        self.error(vLog, 
                            '%sInternal: Invalid segment ID \'%s\'. Each seg id within a ListNode must start with \'_\'.', 
                            self.indent, childSegID)
                    self.indent.decrement()
                self.popLastStep()  # pop list segment indicator step off the path
            #
            # validate non-list 'simple' treeNode segment
            elif isinstance(treeOrLeafNode, DynO):      
                treeNode = treeOrLeafNode
                segName = treeNode.getName()   
                self.pushNextStep(segName)  # add as next step in the path
                # apply most narrowly applicable segment level rules from those defined for tree node at this location
                qPath = self.getCurrPath()
                mSegScope = self.getMostNarrowlyApplicableRulesScopeForPath(qPath)          # matches seg level rules like 'SEGX' or 'SEGX?_XXX' or '*'
                vLog.debug('%sValidating elements within simple segment \'%s\'', self.indent, mSegScope)
                if mSegScope in self.rules:
                    if DEBUG_SCOPE_TRACING:
                        vLog.debug('%sApplying simple segment rules to \'%s\'', self.indent, mSegScope)
                    segRules = self.rules[mSegScope]
                    for rule in segRules:
                        rule.applyTo(treeNode, vLog, self)
                else:
                    if DEBUG_SCOPE_TRACING:
                        vLog.debug('%sNo simple segment rules applicable to \'%s\'', self.indent, qPath)
                    pass
                self._validateChildren(treeNode, vLog)
                self.popLastStep()  # pop last step off the path
            #
            # validate scalar valued leafNode
            else:   # must be a scalar valued leaf node
                leafNode = treeOrLeafNode
                # determine whether to use use 'name scoped' or 'fully scoped' rule set for the leaf value
                # note: rules with a name specific scope (mScope= 'SEGX?_XY'), if present, 
                # will override fully scoped rules (mScope= 'SEGX*') defined for that type of segment 
                # if applicable.
                qPath = self.getCurrPath()
                mLeafValueScope = self.getMostNarrowlyApplicableRulesScopeForPath(qPath)      
                rulesToApply = None
                if mLeafValueScope:
                    if DEBUG_SCOPE_TRACING:
                        vLog.debug('%s*Using leaf value rules scoped to \'%s\'.', self.indent, mLeafValueScope)
                    rulesToApply = self.rules[mLeafValueScope]
                     # apply rules to segs at current node in tree
                    for ruleToApply in rulesToApply:
                        ruleToApply.applyTo(leafNode, vLog, self)                
                else:
                    if DEBUG_SCOPE_TRACING:
                        vLog.debug('%s*No leaf node rules applicable to \'%s\'', self.indent, qPath)
                    pass           
        else:
            # tree was empty
            vLog.debug('%sEmpty tree, returning <<<<.', self.indent)
        self.indent.decrement()

    def _validateChildren(self, treeNode, vLog):
        self.indent.increment()
        # if this is a regular seg node (not just a scalar attribute),
        # then recursively apply validation rules to attributes and subtrees
        if isinstance(treeNode, DynO):     
            # vLog.debug('%sValidating segment \'%s\' child field values.', self.indent, treeNode.getName())
            for attrName, attrValue in [(k, treeNode[k]) for k in treeNode.valueFieldsIter()]:
                pushedStepLocally = False
                isNamedSegListItem = attrName.startswith('_')
                # only for name SegList item segment or simple scalar values!!
                if isNamedSegListItem:
                    self.pushNextStep(attrName)     # add 'attrName' to end of path (like '_ATTR')
                    pushedStepLocally = True
                elif not isinstance(attrValue, DynO):
                    self.pushNextStep(attrName)     # add 'attrName' to end of path (like 'ATTR')
                    pushedStepLocally = True
                # validate all child node values, recursively, depth-first
                self._validate(attrValue, vLog)
                if pushedStepLocally:
                    self.popLastStep()              # pop step from end of path
        else:
            vLog.error('%sInternal: _validate children called with singleton scalar node from segment %s.', 
                self.indent, self.path[-1])
        self.indent.decrement()
        

# test case           
if __name__=='__main__':
    
    import logging
    eLog.setLevel(logging.DEBUG)

#    consOut = logging.StreamHandler()
#    consOut.setLevel(logging.DEBUG)
#    eLog.addHandler(consOut)

    DEBUG_PATH_STACK = False
    DEBUG_SCOPE_MATCHING = False
    DEBUG_SCOPE_TRACING = False
    DEBUG_RULE_TRACING = False

    dataTree = y(_Y_NAME='RSTUDY',
        TITLE = 'Virus Growth Study',
        STARTDT = '09/11/2009',
        FUNDING = y(_Y_NAME='FUNDING',
            ACCTNUM = '2260',
            ASCHEDULE = 'Q',    # renewed by quarter
            FUNDSRC = 'GRT',
            PASSWD = '050507',
            # GRANTOR='Foundation for Shady Research',
            HISTORY = y(_Y_NAME='HISTORY', _Y_LIST=True,
                _1=y(_Y_NAME='_1', PER='1', AMT='12500', CARRYOVER='1100'),
                _2=y(_Y_NAME='_2', PER='2', AMT='37000', EALLOC='6000', CARRYOVER='2300'),
                _3=y(_Y_NAME='_3', PER='3', AMT='9000',  ),
                _4=y(_Y_NAME='_4', PER='6', AMT='40000', EALLOC='3000', EARSN='TA1', EAHRS='200', EARATE='15.00'),
            ),
        ),
        STAFF = y(_Y_NAME='STAFF', _Y_LIST=True, 
            _1 = y(_Y_NAME='_1', 
                    MEMBER=y(_Y_LIST=True, _Y_NAME='MEMBER',
                        _PUBS=y(_Y_NAME='---', AUTH=15, COAUTH=3),
                        _PRIN=y(_Y_NAME='---',    RLVL='1', FIRST='Silverman', EID='666777')),
                ),
            _2 = y(_Y_NAME='_2',
                    MEMBER=y(_Y_LIST=True, _Y_NAME='MEMBER',
                        _ASSC=y(_Y_NAME='---',    RLVL='2', FIRST='Fletcher',                EDLVL='MD')),
                ),
            _3 = y(_Y_NAME='_3',
                    MEMBER=y(_Y_LIST=True, _Y_NAME='MEMBER',
                        _STUD=y(_Y_NAME='---',    RLVL='S6', FIRST='Goldsmith', SLVL='GR',  ADVISOR='Silverman')),
                ),
            _4 = y(_Y_NAME='_4',
                    MEMBER=y(_Y_LIST=True, _Y_NAME='MEMBER',
                        _PUBS=y(_Y_NAME='---', COAUTH=4),
                        _STUD=y(_Y_NAME='---',    RLVL='S1', FIRST='Ledbetter', SLVL='PG',  ADVISOR='Mercurius')),
                ),
            ),
    )

    testRules = [   
        ('RSTUDY',                              RReqs('TITLE', 'FUNDING', 'STAFF[0-10]')),
        ('RSTUDY',                              RAtomic('STARTDT', 'STAFF')),
        ('RSTUDY.FUNDING',                      RReqs('FUNDSRC', 'ASCHEDULE', 'HISTORY[1-4]')),
        ('RSTUDY.FUNDING',                      ROneOf('ACCTNUM', 'PRIVDONOR')),
        ('RSTUDY.FUNDING',                      RAtomic('GRANTOR', 'ACCTNUM')),
        ('RSTUDY.FUNDING.FUNDSRC',              RValueIn('GRT', 'PRV')),
        ('RSTUDY.FUNDING.PASSWD',               RMustBe('050505')),
        ('RSTUDY.FUNDING.HISTORY*',             RReqs('PER', 'AMT')),
        ('RSTUDY.FUNDING.HISTORY*',             RAtomic('EALLOC', 'EARSN', 'EAHRS', 'EARATE')),
        ('RSTUDY.FUNDING.HISTORY*.PER',         RValueIn('1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12')),
        ('RSTUDY.STAFF*.MEMBER',                RCond('_PRIN', '_PUBS')),   
        ('RSTUDY.STAFF*.MEMBER',                RCond('_ASSC', '_PUBS')),   
        ('RSTUDY.STAFF*.MEMBER?_PUBS',          RReqs('AUTH', 'COAUTH')),   
        ('RSTUDY.STAFF*.MEMBER',                ROneOf('_PRIN', '_ASSC', '_STUD')),   
        ('RSTUDY.STAFF*.MEMBER?_STUD',          RReqs('SLVL', 'ADVISOR', 'LAST', 'FIRST')),   
        ('RSTUDY.STAFF*.MEMBER?_STUD.RLVL',     RValueIn('S1','S2','S3','S4')),   
        ('RSTUDY.STAFF*.MEMBER?_STUD.SLVL',     RValueIn('UG','GR','PG')),   
        ('RSTUDY.STAFF*.MEMBER?_PRIN',          ROneOf('EID', 'LAST')),   
        ('RSTUDY.STAFF*.MEMBER?_PRIN',          RCond('LAST', 'FIRST')),   
        ('RSTUDY.STAFF*.MEMBER?_PRIN',          RReqs('EDLVL',)),   
        ('RSTUDY.STAFF*.MEMBER?_PRIN.RLVL',     RValueIn('1','2')),   
        ('RSTUDY.STAFF*.MEMBER?_ASSC',          ROneOf('EID', 'LAST')),   
        ('RSTUDY.STAFF*.MEMBER?_ASSC',          RCond('LAST', 'FIRST')),   
        ('RSTUDY.STAFF*.MEMBER?_ASSC',          RReqs('EDLVL',)),
        ('RSTUDY.STAFF*.MEMBER?_ASSC.RLVL',     RValueIn('3','4')),      
    ]
    
    fieldDict = {
        'RSTUDY' :                          'RSTUDY: Details of the research study',
        'RSTUDY.TITLE':                     'TITLE: Official title of the study',
        'RSTUDY.STARTDT':                   'STARTDT: Date on which study officially commenced',
        'RSTUDY.FUNDING' :                  'FUNDING: Details of funding for the research study',
        'RSTUDY.FUNDING.FUNDSRC' :          'FUNDSRC: Source of research funding',
        'RSTUDY.FUNDING.PASSWD' :           'PASSWD: Super triple processed big whopper of a DES encrypted password',        
        'RSTUDY.FUNDING.ASCHEDULE' :        'ACSCHEDULE: Accounting schedule used for this period',
        'RSTUDY.FUNDING.ACCTNUM' :          'ACCTNUM: Account number assigned to this source of funding',
        'RSTUDY.FUNDING.PRIVDONOR' :        'PRIVDONOR: Private individual donor that supplied the funds',
        'RSTUDY.FUNDING.GRANTOR' :          'GRANTOR: Institution that granted the funds',
        'RSTUDY.FUNDING.HISTORY' :          'HISTORY: History of study funding, by period, spanning the lifetime (up to now) of the study',
        'RSTUDY.FUNDING.HISTORY*' :         '{HISTORY} HISTORY: History of research study funding during a particular period',
        'RSTUDY.FUNDING.HISTORY*.PER' :     '{HISTORY} HISTORY.PER: Period within the research study funding history',
        'RSTUDY.FUNDING.HISTORY*.AMT' :     '{HISTORY} HISTORY.AMT: Total dollars granted for use during this period',
        'RSTUDY.FUNDING.HISTORY*.CARRYOVER':'{HISTORY} HISTORY.CARRYOVER: Amount carried over to next funding period in the study',
        'RSTUDY.FUNDING.HISTORY*.EALLOC' :  '{HISTORY} HISTORY.EALLOC: Amount allocated to external staff during period',
        'RSTUDY.FUNDING.HISTORY*.EARSN' :   '{HISTORY} HISTORY.EARSN: Reason for external allocation of funds during funding period',
        'RSTUDY.FUNDING.HISTORY*.EAHRS' :   '{HISTORY} HISTORY.EAHRS: Number of hrs funded by external allocation during funding period',
        'RSTUDY.FUNDING.HISTORY*.EARATE' :  '{HISTORY} HISTORY.EARATE: Hourly rate of externally allocated research during funding period',
        'RSTUDY.STAFF' :                    'STAFF: Listing all members of the research staff',
        'RSTUDY.STAFF*' :                   '{STAFF} Staff info details for members of the research staff',
        'RSTUDY.STAFF*.MEMBER?_PUBS' :      '{STAFF} {MEMBER} Detailed publication history for a member of the research staff',  
        'RSTUDY.STAFF*.MEMBER?_PUBS.AUTH' : '{STAFF} {MEMBER} AUTH: Number of publications where staff member was the author',  
        'RSTUDY.STAFF*.MEMBER?_PUBS.COAUTH':'{STAFF} {MEMBER} COAUTH: Number of publications where staff member was a co-author',  
        'RSTUDY.STAFF*.MEMBER?_STUD' :      '{STAFF} {MEMBER} Info describing a student member of the research staff',    
        'RSTUDY.STAFF*.MEMBER?_PRIN' :      '{STAFF} {MEMBER} Info describing a principal researcher on staff',
        'RSTUDY.STAFF*.MEMBER?_ASSC' :      '{STAFF} {MEMBER} Info describing an associate researcher on staff',
        'RSTUDY.STAFF*.MEMBER' :            '{STAFF} MEMBER: Contains info segments describing a member of the study\'s research staff',     
        'RSTUDY.STAFF*.MEMBER*' :           '{STAFF} {MEMBER} Info segments describing a member of the study\'s research staff',              
        'RSTUDY.STAFF*.MEMBER*.RLVL' :      '{STAFF} {MEMBER} RLVL: A staff member\'s research level within this study',
        'RSTUDY.STAFF*.MEMBER*.FIRST' :     '{STAFF} {MEMBER} FIRST: First name of staff member',
        'RSTUDY.STAFF*.MEMBER*.LAST' :      '{STAFF} {MEMBER} LAST: Last name of staff member',
        'RSTUDY.STAFF*.MEMBER*.EDLVL':      '{STAFF} {MEMBER} EDLVL: Highest educational level achieved by staff member',        
        'RSTUDY.STAFF*.MEMBER*.SLVL':       '{STAFF} {MEMBER} SLVL: Current level of study for student staff member',
        'RSTUDY.STAFF*.MEMBER*.ADVISOR':    '{STAFF} {MEMBER} ADVISOR: Staff advisor name for student staff member',                
        'RSTUDY.STAFF*.MEMBER*.EID':        '{STAFF} {MEMBER} EID: University employee ID of non-student staff member',
        }
    
    segIDFormats = {
        'STAFF' : 'Staff member #{segID}',
        'HISTORY':'{segOrd} funding history entry',
        'MEMBER': {
            'PRIN': 'Principal staff info',
            'ASSC': 'Associate staff info',
            'STUD': 'Student staff info',
            'PUBS': 'Publication history',
            }
        }
    
    ve = ValidationEngine(testRules, fieldDict, segIDFormats)
    if ve.validate(dataTree, eLog):
        eLog.info('Validation OK, no errors were encountered.')
    else:
        eLog.info('Validation FAILED, %d errors were encountered.' % ve.errors)
        print '\n\nThe following %s errors were discovered during content validation:\n' % ve.errors
        for errorArgs in ve.errorList:
            # vLog.info('\n'+errorArgs[0], *errorArgs[1:])
            print errorArgs[0] % errorArgs[1:]
            print  
    
    
    