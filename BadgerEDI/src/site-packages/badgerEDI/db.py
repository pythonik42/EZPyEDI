
'''
Jomar DB object-to-relational mapping classes used by the Badger EDI system

@author: jknaus
'''
from badgerEDI import eLog

from sqlalchemy import *
from sqlalchemy.orm import *
from sqlalchemy.sql import func
from sqlalchemy.orm import mapper as sqla_mapper

import bots.botsinit
import bots.botsglobal
import os
import copy
import time
from datetime import date
    
# determine our execution environment (DEV or PRD)
# this determines which Jomar DB instance we will be using
if bots.botsglobal.ini:
    environment = bots.botsglobal.ini.get('webserver','environment','development')
else:
    # if BOTS not intialized, then assume we are testing in DEV environemnt
    environment = 'development'
    
#===============================================================================
# Setup SqlAlchemy ORM to manage object persistence and lifecycle
#
# Initialize SqlAlchemy to use the appropriate Jomar DB instance/drivers
# based on execution environment (PRD or DEV) and OS (WinDoz or Linux) 
#===============================================================================

# detect OS and DB driver being used
if os.name=='nt': # OS is windows
    eLog.info('Detected that host OS is Windows. Using Microsoft MS SQL Server Native ODBC driver.')
else:             # OS is Linux
    eLog.info('Detected that host OS is Linux. Using Progress DataDirect Native MS SQL ODBC driver.')

# setup DB connect parameters:
# DSN names are same in both Win and Linux ODBC.ini files, so this works in both contexts
if environment == 'production':
    eLog.info('PRODUCTION PRODUCTION *** Using JOMAR Production DB ***')
    UNAME = 'sa'
    UPASS = 'brent'
    DBNAME = 'JoProdDB'
else:
    eLog.info('TEST TEST TEST TEST *** Using JOMAR Test DB ***')
    UNAME = 'sa'
    UPASS = 'brent'
    DBNAME = 'JoTestDB'
url = 'mssql://%s:%s@%s' % (UNAME, UPASS, DBNAME)

# create the engine and metadata for SqlAlchemy
JoEngine = create_engine(url)
metadata = MetaData(JoEngine)

# create our custom session mapper: this one utilizes init attrib values
def session_mapper(scoped_session):
    def mapper(cls, *arg, **kw):
        validate = kw.pop('validate', False)
    
        if cls.__init__ is object.__init__:
            def __init__(self, **kwargs):
                for key, value in kwargs.items():
                    if validate:
                        if not cls_mapper.has_property(key):
                            raise TypeError(
                                "Invalid __init__ argument: '%s'" % key)
                    setattr(self, key, value)
                    # scoped_session.add(self)
            cls.__init__ = __init__
        cls.query = scoped_session.query_property()
        cls_mapper = sqla_mapper(cls, *arg, **kw)
        return cls_mapper
    return mapper

# global Session object used to access and manage SqlAlchemy ORM    
Session = scoped_session(sessionmaker(autoflush=True, bind=JoEngine))
mapper = session_mapper(Session)

#===============================================================================
# Define SqlAlchemy ORM managed DB record classes 
#===============================================================================

from badgerEDI.dyno import DynO

# Jomar DB tables
class JoOrder(DynO): pass 
class JoOrderLine(DynO): pass
class JoWordpadNote(DynO): pass
class JoCustomer(DynO): pass

# BadgerSoft extensions to Jomar
class JoUPCToSKULookup(DynO): pass

# BadgerEDI tables
class JoPartnerShipToLocation(DynO): pass
class JoEDIOrderTracking(DynO): pass
class JoOrderChange(DynO): pass
class JoOrderLineChange(DynO): pass

#===============================================================================
# Configure SqlAlchemy to map these tables dynamically
#===============================================================================

# Jomar managed tables
_joOrderTable = Table('TXUYUV10', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoOrder, _joOrderTable, validate=True)
_joOrderLineTable = Table('TXUYUF12', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoOrderLine, _joOrderLineTable, validate=True)
_joWordpadNoteTable = Table('GNPWPD00', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoWordpadNote, _joWordpadNoteTable, validate=True)
_joCustomerTable = Table('TXUYKD00', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoCustomer, _joCustomerTable, validate=True)

# BadgerSoft managed tables (i.e. tables in support of apps created by IT staff here at Badger Sportswear)
_joUPCToSKULookupTable = Table('bdg_tblBlankUPCS', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoUPCToSKULookup, _joUPCToSKULookupTable, validate=True)

# BadgerEDI managed tables
_joShipToLocationTable = Table('edi_PartnerShipToLocation', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoPartnerShipToLocation, _joShipToLocationTable, validate=True)
_joEDIOrderTrackingTable = Table('edi_OrderTracking', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoEDIOrderTracking, _joEDIOrderTrackingTable, validate=True)

# Currently unused, but may be needed in future
_joOrderChangeTable = Table('edi_OrderChange', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoOrderChange, _joOrderChangeTable, validate=True)
_joOrderLineChangeTable = Table('edi_OrderLineChange', metadata, autoload=True, autoload_with=JoEngine)
mapper(JoOrderLineChange, _joOrderLineChangeTable, validate=True)

# cache of loaded SKU info to avoid a bad reference problem when using SKU table persistence and object 
# deepcopy together (not sure why, but keeping references to objs at DB read time avoids the problem)
_vendorSKUTable = {}

