'''
EDI Utility Classes

@author: jknaus
'''
from badgerEDI import eLog

from sqlalchemy import *
from sqlalchemy.orm import *
from sqlalchemy.sql import func

from badgerEDI.bedislib import *
from badgerEDI.db import *
from badgerEDI.rules import *

import bots.transform as transform
from bots.botsconfig import *
import bots.botsglobal

import pickle


#===============================================================================
# This class stores and manages EDI processing results
#===============================================================================
    
class EdiResults(object):

    def __init__(self, docType, refID):
        self.msgContextDict = dict()  # keyed by context: line# or docType string (i.e. 'SO')
        self.hasErrors = 0
        # self.customer = customer
        self.docType = docType
        self.refID = refID
        self.allMessages = list()
        
    def getMsgEntryListFor(self, context):
        # do not log anything in this method, will cause stack overflow thru recursion
        msgList = self.msgContextDict.get(context, None)
        if not msgList:
            msgList = list()  # create a new one and add to the dict
            self.msgContextDict[context] = msgList
        return msgList
    
    def getMessageLogAsList(self):
        return self.allMessages
        
    def addMessage(self, msgType, msg, line=0):
        # do not log anything in this method, will cause stack overflow thru recursion
        if msgType in ERROR_MSG_TYPES:
            self.hasErrors += 1
        context = line or self.docType
        msgList = self.getMsgEntryListFor(context)
        msgList.append((msgType, msg))
        
        # also save in list of all msgs ordered cronologically
        self.allMessages.append((msgType, msg))
    
    def getMessageAsNote(self, line=0):
        context = line or self.docType
        if context in self.msgContextDict.keys():
            msgList = self.getMsgEntryListFor(context)
            msgLines = list()
            
            if context == self.docType:
                msgHeader = EDI_NOTE_HEADER_FORMAT_STRING % ('EDI Order Info',)
            else:
                msgHeader = EDI_NOTE_HEADER_FORMAT_STRING % ('EDI Order Line Info',)
            msgLines.append(msgHeader)
                
            # append the remaining message lines to the note and join w/ newlines
            for (msgType, msg) in msgList:
                if msgType in WORDPAD_NOTE_MSG_TYPES:
                    msgLine = '%s %s' % (MSG_TYPE_LINE_PREFIX.get(msgType, UNKNOWN_MSG_TYPE_LINE_PREFIX), msg)
                    msgLines.append(msgLine)
                    
            if len(msgLines)>1:
                msgText = '\n'.join(msgLines)
                # for debugging
                eLog.debug('%s Note [%s]...\n%s' % (self.docType, context, msgText))
                return msgText
            else:
                # no note-worthy messages for selected context
                return None
        else:
            # no messages of any kind for selected context
            return None
        
    def getMessageLogFilteredBy(self, messageTypes):
        msgList = self.getMessageLogAsList()
        msgLines = list()
        
        # append the remaining message lines to the note and join w/ newlines
        for (msgType, msg) in msgList:
            if msgType in messageTypes:
                msgLine = '%s%s' % (
                    EMAIL_NOTIFICATION_LINE_PREFIX.get(msgType, UNKNOWN_MSG_TYPE_LINE_PREFIX_FOR_EMAIL), 
                    msg)
                msgLines.append(msgLine)
                
        if len(msgLines) > 1:
            msgText = '\n'.join(msgLines)
            # for debugging
            #eLog.debug('//----Start of EDI processing log---------------------------------------------\\')
            #eLog.debug(msgText)
            #eLog.debug('\\----End of EDI Processing Log-----------------------------------------------//')
            return msgText
        else:
            # no note-worthy messages for selected context
            return 'No entries in EDI Processing log.'
                        
#    def raiseExceptionIfErrors(self):
#        if self.hasErrors:
#            eLog.info('Badger EDI encountered errors during processing of doc %s!', self.refID)
#            raise BEDISx_MappingError(errMsg=self.getMessageString())
#        else:
#            eLog.info('Processing of EDI doc %s was successful, no errors encountered.', self.refID)

class LogRecorder(Filter):
    
    def __init__(self, eMgr, eResults):
        self.eResults = eResults
        self.eMgr = eMgr
        
    def filter(self, record):
        """
        Gets called by Logger when we are filtering its log records.
        
        Determine if a record is loggable by consulting all the filters.

        The default is to allow the record to be logged; any filter can veto
        this and the record is then dropped. Returns a zero value if a record
        is to be dropped, else non-zero.
        
        For our purposes, we use this as an opportunity to capture Log records 
        as they are logged to the standard EDI logger 'eLog'.
        """

        ## Save message text in proper context 
        msgContext = self.eMgr.getMsgContext()
        
        # pull what we need from the logging Record
        msgLevel = record.levelno
        msgText = record.getMessage()

        # echo the message to our EDI notes log
        self.eResults.addMessage(msgLevel, msgText, msgContext)
        
        # let the logger continue processing this record
        return 1

class EdiMgr(object):
    """
    Base class providing methods for EDI processing and results reporting
    
    Each EDI mapping script will create it own instance of EdiMgr (or a subclass).
    
    EdiMgr is a good place to put common methods that can be used by all mapping
    scripts.  It also defines a number of 'hook' methods whereby a subclass
    can implement it's own specific variant of a commonly defined EdiMgr
    behavior. 
    """

    def __init__(self, joDocType=None, joRefNum=None):
        """
        Create a new EDI Manager.
        
        Subclasses should invoke this base class __init__ from their init.
        
        joRefNum = ref number string like '0000012376' referencing a 'doc' in Jomar
        joDocType = doc type being processed/generated. Use these values...
        
            docType       refNum
            ----------    ---------------------------
            'IN'  --->    Jomar Invoice Number
            'SO'  --->    Jomar Sales Order Number
        """

        self.refNum = joRefNum            
        self.docType = joDocType
        self.ediErrorText = ''
        self.ediErrorCnt = 0
        self.currLine = 0
        self.eResults = None
        self.logRecorder = None
        self.childLogRecorder = None
        self.refNum = None
        self.docType = None
        self.ediNotes = None
        self.tpSettings = dict()    # empty dict, default if not set
        self.outDocValidationConfig = None
        self.ediAdminErrorLog = None
        self.ediErrorLog = None
                
    def setTPSettings(self, tpSettings):
        self.tpSettings = tpSettings
        
    def getTPSettings(self):
        return self.tpSettings
        
    def setOutDocValidationConfig(self, vc):
        self.outDocValidationConfig = vc
        
    def getOutDocValidationConfig(self):
        return self.outDocValidationConfig
        
    def getCustomerPONumber(self, poNumber):
        if poNumber and '-' in poNumber:  
            # strip off shipoTo suffix appended to direct shipment/alternate locations PO numbers
            (originalPO, locationID) = poNumber.split('-',-1)
            return originalPO  # now PO number matches customer's PO number
        else:
            return poNumber.strip()
    
    # this is used by eMgrs for both IN810 and SH856 X12 EDI doc generation      
    def getExtraEdiValuesDict(self, noteValue):
        """
        Parse out Extra EDI values stored in WordPad SO Note #10 text, ONE PER LINE.
        
        Line format: <Name>:<Value>
        
        Comment lines may be added to this SO note. These can be distinguished by the 
        '#' appearing as the first non-whitespace character on the line.  All text on a 
        comment line will be ignored for purposes of EDI processing.
        
        Note: All whitespace is removed from beginning and end of parsed keys and values.
        """
        if not noteValue:
            eLog.warn('No ExtraEdiValues found in SO %s WordPad note #10 on SO %s.', self.refNum)
            return dict()   # empty
        else:
            eLog.debug('Parsing ExtraEdiValues from SO %s WordPad note #10.', self.refNum)
            # parse out values in ExtraEdiInfo
            ediValues = dict()
            evLines = unescapeXML(noteValue).splitlines()
            for evLine in evLines:
                evLine = evLine.strip()  # trim leading and trailing spaces
                if len(evLine) and evLine[0]=='#':
                    continue    # do not process comment lines that start with a '#'
                evArgs = evLine.split(':',2)  # split into two parts using ':' as the split char
                if (len(evArgs)==2):
                    key = evArgs[0].strip()
                    valString= evArgs[1].strip()
                    if valString and key:
                        ediValues[key] = valString
                    eLog.debug('    * %s = %s' % (key, valString))
                else:
                    eLog.error('    EDI value line not in expected \'Name:Value\' format: %s' 
                                    % evLine)
                    eLog.error('    %s #%s has a fatal EEVs format error!  Please correct this error before reprocessing.' 
                                    % (self.docType, self.refNum))
            return ediValues
    
    def addEdiOrderTrackingEntryFor(self, salesOrder, genXMLFlag='A'):
        orderTracker = JoEDIOrderTracking() 
        orderTracker.CustomerPO = self.getCustomerPONumber(salesOrder.CusPONumber)
        orderTracker.ShipType = salesOrder.ShipType
        if salesOrder.ShipType=='CD' and salesOrder.ShipToCrossDockLocID:
            orderTracker.CrossDockLocID = salesOrder.ShipToCrossDockLocID
            orderTracker.MasterBOLNumber ='MBOL-'+orderTracker.CustomerPO
        orderTracker.CustomerPOType = salesOrder.CusPOType
        orderTracker.DatePOReceived = salesOrder.CusPODate
        orderTracker.CustomerSoldToID = salesOrder.JoSoldToCustomer
        orderTracker.CustomerShipToLocation = salesOrder.ShipToIDCode
        orderTracker.JomarOrderNumber = salesOrder.JoOrderNumber
        orderTracker.OrderCancelled = 'N'
        orderTracker.OrderClosed = 'N'
        orderTracker.GenerateXML = genXMLFlag 
        Session.add(orderTracker)
        
    def createSONote_EdiResults(self, salesOrder, notesLine):
        #eLog.info('Saving EDI messages in SO %s note #%s for both order and lines:' % 
        #        (salesOrder.JoOrderNumber, notesLine))
        msgContextDict = self.eResults.msgContextDict
        if msgContextDict:
            keyList = self.eResults.msgContextDict.keys()
            docCode = 'SO'+salesOrder.JoOrderNumber.zfill(10)
            for msgContext in msgContextDict.keys():
                msgText = self.eResults.getMessageAsNote(msgContext)
                if msgText:  # if no msg for this part of the order, then skip it
                    if msgContext == self.eResults.docType:
                        noteType = '#D'   # sales order note
                        lineCodeSuffix = ''
                    else:
                        noteType = '#L'   # sales order line note                    
                        lineCodeSuffix = (str(msgContext)+'0').zfill(5)
                    if len(msgText)>=4000:
                        eLog.warning('Message text for SO EDI results note > 4000 chars, truncating.')
                        # truncate message
                        notesMsgText = msgText[:3995] + '...'
                    else:
                        notesMsgText = msgText  
                    # save incoming EDI error msgs in WordPad Sales Order Notes #20 (PO), #21 (PC1), #22 (PC2), etc.
                    # both at the doc level and at the line level where specified
                    wordpadNote = JoWordpadNote()
                    wordpadNote.WPBNR = salesOrder.JoBusinessUnit
                    wordpadNote.WPPLT = salesOrder.JoBasePlant
                    wordpadNote.WPNTYP = noteType   # sales order or order line item note
                    wordpadNote.WPCODE = docCode+lineCodeSuffix
                    wordpadNote.WPLINE = notesLine
                    wordpadNote.WPPFLG = 'N'    # not printed!
                    wordpadNote.WPFL10 = 'Y'    # is an EDI note
                    wordpadNote.WPTEXT = notesMsgText
                    Session.add(wordpadNote)
                    
                    # return the un-truncated note text
                    return msgText
        else:
            eLog.info('No EDI messages, so no notes were saved for SO %s.', salesOrder.JoOrderNumber)
            return None
            
    def saveTree(self, partnerID, obj, templateName, docID, ta_info):
        # important: store templateName|docID in ta.botskey
        ta_info['botskey'] = '%s|%s_%s' % (templateName, partnerID, docID)
        docKey = '%s__%s_%s' % (templateName, partnerID, docID)
        
        webroot = bots.botsglobal.ini.get('webserver','webroot','http://localhost:8088/')
        obj.EdiViewDocURL = '%sfiler/?action=viewdoc&edidoc=%s' % (webroot,docKey)
        
        nutsDir = bots.botsglobal.ini.get('directories','nuts','/EDI/archive/nuts')
        pFileName = '%s/%s_%s.nut' % (nutsDir, partnerID, docID)
        
        with open(pFileName, 'wb') as f:
            pickle.dump(obj, f)
        eLog.info('Storing %s data. %s doc content saved to file %s' % (templateName, docID, pFileName))
         
    def getMsgContext(self):
        return self.currLine or self.docType
     
    def startLogCapture(self, log):
        if not self.logRecorder:
            self.logRecorder = LogRecorder(self, self.eResults)
        else:
            # remove old one and add it back below
            log.removeFilter(self.logRecorder)
        log.addFilter(self.logRecorder)

    def stopLogCapture(self, log):
        if self.logRecorder:
            log.removeFilter(self.logRecorder)    
            del self.logRecorder
        
    def startProcessingDoc(self):
        self.eResults = EdiResults(self.docType, self.refNum)
        self.currLine = 0
        
    def finishProcessingDoc(self, obj, ifErrorMsg=None):
        noteText = None
        if self.eResults.hasErrors:
            noteText = self.eResults.getMessageAsNote()
        if noteText:
            if not ifErrorMsg:
                ifErrorMsg = 'EDI processing FAILED for %s %s' % (getDirectedEdiDocType(obj.EdiDocType), obj.EdiDocID)
            errMsgText = '%s Fatal errors found!\n%s' % (ifErrorMsg, noteText)
            self.ediErrorText += '\n' + errMsgText
            self.ediErrorCnt += self.eResults.hasErrors
            self.ediAdminErrorLog = self.eResults.getMessageLogFilteredBy(ADMIN_ERROR_LOG_MSG_TYPES)
            self.ediErrorLog = self.eResults.getMessageLogFilteredBy(ERROR_LOG_MSG_TYPES)
            self.processedDocFAILED(obj)
        else:
            eLog.info('EDI processing OK for %s %s' , getDirectedEdiDocType(obj.EdiDocType), obj.EdiDocID)
            self.processedDocOK(obj)
        # explicitly dispose of some items we no longer need
        del self.eResults
        
    def finishProcessingEdi(self, obj, ta_info=None):
        # save error log (if any) with the object        
        obj.EdiErrorLog = self.ediErrorLog
        obj.EdiAdminErrorLog = self.ediAdminErrorLog

        # save our updated PO incoming doc data tree (again) for rendering later...
        self.saveTree(obj.EdiFromPartnerID, obj, obj.EdiDocType, obj.EdiDocID, ta_info)

        # email the EDI error log to CSRs (edi@badgersportswear.com) if errors were logged
        # email the EDI debug log (with errors) to EDI administrator if errors were logged
        if self.ediErrorLog:
            sendX12ProcessingErrorEmail(
                ('%s%s, %s errors' % (getEdiDirectionArrow(obj.EdiDocType), obj.EdiDocID, self.ediErrorCnt)), 
                self.ediErrorLog)
            sendX12ProcessingAdminErrorEmail(
                ('%s%s, %s errors' % (getEdiDirectionArrow(obj.EdiDocType), obj.EdiDocID, self.ediErrorCnt)), 
                ('%s EDI doc %s has errors.\nSee BOTS \'file errors\' or engine.log for more details.\n\n%s' %
                    (obj.EdiDocType, obj.EdiDocID, self.ediErrorLog)))
            self.processedEdiFAILED(obj)
            raise BEDISx_MappingError(errMsg=self.ediAdminErrorLog)
        else:
            self.processedEdiOK(obj)
            
    def processedDocOK(self, obj):
        # provides a hook for subclasses to perform custom notifications if OK
        return None
            
    def processedEdiOK(self, obj):
        # provides a hook for subclasses to perform custom notifications if OK
        return None
    
    def processedDocFAILED(self, obj):
        # provides a hook for subclasses to perform custom notifications if FAILED
        return None
            
    def processedEdiFAILED(self, obj):
        # provides a hook for subclasses to perform custom notifications if FAILED
        return None
    
    def generateOutDocContent(self, out, localVars, globalVars=globals()):

        vc = self.getOutDocValidationConfig()
        if vc:
            outDocTransformTree = vc.getOutDocMap(out)
            outDocTransformTree.evaluate(globalVars, localVars)
            outDocContent = outDocTransformTree.getResultsTree()
            return outDocContent
        else:
            return None
                
    def validateOutDocContent(self, outDocContentTree):
        if self.eResults.hasErrors:
            elog.debug('### EDI VALIDATION: SKIPPED ### \nDocument generation errors must be fixed before validating content.')
            return False
        
        vc = self.getOutDocValidationConfig()
        if vc:
            outDocFieldDescriptions = vc.fieldDescriptions 
            outDocNamedSegmentFormats = vc.namedSegmentFormats
            outDocContentRules = list(vc.contentRules)
            vEngine = ValidationEngine(outDocContentRules, outDocFieldDescriptions, outDocNamedSegmentFormats)
            if not vEngine.validate(outDocContentTree, eLog):
                eLog.info('### EDI VALIDATION: FAILED ### \nOutgoing document failed validation check. See EDI processing log for details.')
                return False
            else:
                eLog.info('### EDI VALIDATION: PASSED ### \nOutgoing document successfully passed validation checks.')
                return True
        else:       
            eLog.debug('### EDI VALIDATION: SKIPPED ### \nNo content validation rules, neither default nor partner-defined.')
            return True
        
    def mergeCustomTPMappingRules(self, outDocTransformTree):

        if self.tpSettings['OutDocTransformChanges']:
            eLog.info('Applying customer specific out doc generation rules for trading partner.')
            outDocTransformTree.mergeAll(self.tpSettings['OutDocTransformChanges'])
        else:
            eLog.info('No custom mapping rules defined for this partner, using default mapping.')
            
        
#=======================================================================================================================
# utility functions
#=======================================================================================================================
def execSP(conn, spName):
    eLog.info('Exec SP [%s]' % (spName,))
    
    trans = conn.begin(subtransactions=True)
    try:
        results = conn.execute(text(spName))
        resultRows = list()
        if not results.closed:
            for row in results:
                eLog.debug('  (%s)' % (row,) )
                resultRows.append(row)
        trans.commit()
        # eLog.debug('SP [%s] executed w/o incident.' % (spName,))
        return resultRows
                
    except:
        eLog.error('A SQL error occurred during execution of SP.')
        trans.rollback()
        raise
    
    
def getJoDefaultOrderValuesForCustomer(conn, joCustomerID):
    trans = conn.begin(subtransactions=True)
    try:
        jc = conn.query(JoCustomer).filter_by(KKDN=joCustomerID).first()
        default_JoOrder = rec and {
            'JoPOType':'SO',
            'JoBusinessUnit':'001',
            'JoBasePlant':'01',
            'JoOrderAction':'B',
            'JoOrderSelection1':jc.KGR1 or '',  # identifies fee schedule for purchases
            'JoOrderSelection2':jc.KGR2 or '',
            'JoOrderSelection3':jc.KGR3 or '',
            'JoSalesRep1':jc.UVT1 or '',        # aka SalesAgencyCommission
            'JoSalesRep2':jc.UVT2 or '',
            'JoSalesRep3':jc.UVT3 or '',
            'JoRepCommission1':jc.KPV1 or '0.00',
            'JoRepCommission2':jc.KPV2 or '0.00',
            'JoRepCommission3':jc.KPV3 or '0.00',
            'JoCommissionPercent':jc.KVT2PR or '0.00',
            'JoOrderDeliveryTermsCode':jc.KTXL or '',
            'JoOrderShipViaTermsCode':jc.KTXV or '',
            'JoOrderPaymentTermsCode':jc.KTXZ or '',
            'JoOrderAdjPercent1':jc.KAB1 or '0.00',
            'JoOrderAdjPercent2':jc.KAB2 or '0.00',
            'JoOrderDiscountPercent':jc.KRB1 or '0.00',
            'JoAllowPartialShipment':jc.KPSHP or '',
            'JoShippingLabelNotesReq':jc.KSLREQ or '',
            'JoCustomerSoldTo':jc.KPGR or '',   # usually the same as BillTo
            'JoFactor':jc.KFCT or '',
            'JoCustomerRemitTo':jc.KBVP or '',  # if specified, then RemitTo this factor (i.e. customer with this factorID)
            'JoCustomerRemitToAccount':jc.KBVT or '',
            'JoCurrencyCode':j.KWAE or 'USD',
            #
            ### these columns should be auto-populated by order batch load process
            ### which copies appropriate values based on BillTo customer info
            # 
            #'JoOrderPlanStats':'REL',
            #'JoLocation':'01',
            #'JoBlindShip':'N',
            #'JoOrderDeliveryTermsText':'To Be Determined',
            #'JoOrderPaymentTermsText':'Net 30 Days',
            #'JoShippingCode':'BK',
            #'JoTruckLoadingReq':'FT',  # Full Truck
            #'JoShipDateReq':'P2',      # ASAP
            #'JoConsignmentSB':'CS',
            #'JoCustomerCreditStatus':'AAA',
            #'JoInternalSystemCodeULOE':'',
            #'JoUCAMT':'0',
            #'JoUADAT':'0',
            #'JoUFRTC':'100',
            #'JoUCIT':'0',
            #'JoEstWeight':'0',
            #'JoEstCartonSize':'0',
            }
        trans.commit()
        return default_JoOrder
    
    except:
        eLog.error('A SQL error occurred during execution of getJoDefaultOrderValuesForCustomer().')
        trans.rollback()
        raise

       
def getNextJoOrderNumber(conn):
    trans = conn.begin(subtransactions=True)
    try:
        ## FIXME: DOES NOT WORK WITH EZSOFT DRIVER ON LINUX!!
        #txt = """
        #SET NOCOUNT ON;
        #DECLARE @NEWORDERNUMBER AS INT;
        #EXEC [dbo].[bdg_tblGetOrderNumber] @NEWORDERNUMBER OUTPUT;
        #SELECT @NEWORDERNUMBER
        #SET NOCOUNT OFF;"""[1:]
        #resultRow = conn.execute(text(txt)).fetchall()
        #jonum = resultRow[0][0]
        conn.execute(text('exec dbo.edi_CreateNextOrderNumber'))
        resultRow = conn.execute(text('exec dbo.edi_GetLastOrderNumber')).fetchall()
        jonum = resultRow[0][0]
        eLog.debug("Next Jomar ORDER number is %s", jonum)
        trans.commit()        
        return str(jonum).zfill(10)
    
    except:
        eLog.error('A SQL error occurred during execution of getNextJoOrderNum().')
        trans.rollback()
        raise

_vendorSKUTable = dict()

def lookupVendorStyleNumberByUPC(conn, upc):
    eLog.debug('Fetching VendorStyleNumber for UPC %s' % (upc,))
    #        styleNumber = self.UPCToVendorStyleLookup[upc]
    #        print '         VendorStyleNumber is %s' % styleNumber
    #        return styleNumber # FIX to return StyleNumber
    
    trans = conn.begin(subtransactions=True)
    try:
        rec = conn.query(JoUPCToSKULookup).filter_by(UPCNumber=upc).first()
        if rec is None:
            rval = None
        else:
            # print '  VendorStyleNumber is %s' % rec.JomarSKU
            # Session.add(rec)
            rval = rec.JomarSKU
            _vendorSKUTable[upc] = rec.JomarSKU  # cache it for later (after deepcopy)
        trans.commit()
        return rval
    
    except:
        eLog.error('A SQL error occurred during execution of lookupVendorStyleNumberByUPC().')
        trans.rollback()
        raise
    
def cachedVendorStyleNumberByUPC(upc):
    try:
        return _vendorSKUTable[upc]
    except KeyError:
        return None
    
__cCodeTo2Digits = {
    '' :    'US',
    'USA' : 'US',
    'JAP' : 'JA',
    'CAN' : 'CA',
    }

def translateCountryCodeTo2Digits(cCode):
    if cCode in __cCodeTo2Digits:
        return __cCodeTo2Digits[cCode]
    else:
        return '__'
                    
#===============================================================================
# Manages e-mailing of EdiResults and other notification messages      
#===============================================================================
# from django.core.mail import EmailMultiAlternatives
from django.core.mail import EmailMessage

from django.template import Context, Template
from django.template.loader import render_to_string

def sendEmailAsText(fr, to, subject, msgText):

    msg = EmailMessage(subject, msgText, fr, [to])
    msg.send()

def sendEmailAsHTML(fr, to, subject, msgHTML):

    msg = EmailMessage(subject, msgHTML, fr, [to])
    msg.content_subtype = "html"  # Main content is now text/html
    msg.send()     
    
def sendX12ProcessingOKEmail(docType, **ediDoc):
    
    environment = bots.botsglobal.ini.get('webserver','environment','development')
    if environment == 'production':
        ediDoc['IsTestSystem'] = False
        ediDoc['EdiSystem'] = 'Badger EDI'
        ediDoc['EmailFrom'] = 'TracIT@badgersportswear.com'
        ediDoc['EmailTo'] = 'edi@badgersportswear.com;jknaus@badgersportswear.com'
    else:
        ediDoc['IsTestSystem'] = True
        ediDoc['EdiSystem'] = 'Test EDI'
        ediDoc['EmailFrom'] = 'TracIT@badgersportswear.com'
        ediDoc['EmailTo'] = 'jknaus@badgersportswear.com'
    
    eLog.info('Sending [%s] processing OK notifications to: %s', ediDoc['EdiSystem'], ediDoc['EmailTo'])

    msgText = render_to_string('bots/'+docType+'EmailInEDI.html', ediDoc)
    subjectText = render_to_string('bots/'+docType+'EmailInEDISubject.html', ediDoc)
    
    sendEmailAsHTML(ediDoc['EmailFrom'], ediDoc['EmailTo'], subjectText, msgText)                  
    
def sendX12ProcessingErrorEmail(errorSummary, errorText):
    environment = bots.botsglobal.ini.get('webserver','environment','development')
    if environment == 'production':
        EdiSystem = 'Badger EDI'
        EmailTo = 'edi@badgersportswear.com'
    else:
        EdiSystem = 'Test EDI'
        EmailTo = 'edi@badgersportswear.com'
    
    eLog.info('Sending [%s] processing FAILED error log notifications to: %s.', EdiSystem, EmailTo)

    sendEmailAsText('TracIT@badgersportswear.com', 
                    EmailTo, '['+EdiSystem+'][ERROR]'+errorSummary, errorText)  
    
def sendX12ProcessingAdminErrorEmail(errorSummary, errorText):
    environment = bots.botsglobal.ini.get('webserver','environment','development')
    if environment == 'production':
        EdiSystem = 'Badger EDI Admin'
        EmailTo = 'jknaus@badgersportswear.com'
    else:
        EdiSystem = 'Test EDI Admin'
        EmailTo = 'jknaus@badgersportswear.com'
    
    eLog.info('Sending [%s] processing FAILED admin error/debug log notifications to: %s.', EdiSystem, EmailTo)

    sendEmailAsText('TracIT@badgersportswear.com', 
                    EmailTo, '['+EdiSystem+'][ERROR]'+errorSummary, errorText)             