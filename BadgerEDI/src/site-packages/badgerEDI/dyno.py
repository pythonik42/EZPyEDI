
'''
Dynamic object class

@author: jknaus
'''
from badgerEDI import eLog
from badgerEDI.dmerge  import merge_dictionary
from badgerEDI.bedislib import dictLike
#
#import os
#import copy
#import time
#from datetime import date

#==============================================================================
# DynO (aka Dynamic Object)
#
# this class can be passed a dictionary of initial attribute values at 
# initialization time, it then creates a dynamic attribute for each (key, value) 
# pair specified.
#
# Metatdata attributes have names that start with '_Y_'.
#==============================================================================
class DynO(dictLike):

    def __init__(self, **kw):
        if '__NAME' in kw:  # remember my name, if assigned
            self.setName(kw.pop('__NAME', 'DynO'))
        else:
            self.setName(self.__class__.__name__)
        kw and self.update(kw)
        
    #
    # usage: innY = DynO().loadX12MessageValues(inn)
    #        po.Number = innY.ST.REF.REF02
    #
    def loadX12MessageValues(self, x12Message):
        self.addX12MessageNodeValuesForNode(x12Message.root)
    
    def addX12MessageNodeValuesForNode(self, x12Node):
        segName = x12Node.record.get('BOTSID')
        self.setName(segName)
        # add children as sub-dicts in my dict of dynamic attributes 
        for childNode in x12Node.children:
            nodeTree = DynO()
            nodeTree.addX12MessageNodeValuesForNode(childNode)
            
            childSegName = nodeTree.getName()
            segList = self.get(childSegName)
            
            # if first time segName is seen, create new list and add as attribute w/ segName
            if not segList:
                segList = list()
                self.__setitem__(childSegName, segList)  # eg ST.REF[], ST.CTT[]
            
            # add this seg to the end of the list
            segList.append(nodeTree)
            
        # add all scalar values as fields to seg at this level of tree
        for (fname, fval) in x12Node.record.iteritems():
            if not fname=='BOTSID':
                self.__setattr__(fname, fval)         # eg ST.ST01, ST.ST02
              
    # TODO: needs more testing!  
    @classmethod
    def path(cls, path, **kws):
        if not path:
            return DynO(**kws)
        steps = path.split('.')
        lastStep = steps.pop()
        yCurr = DynO(**kws)  # leaf node
        steps.reverse()  # need to process path bottom-up
        for step in steps:
             stepKws = {lastStep:yCurr}
             yParent = DynO(**stepKws)
             yCurr = yParent
             eLog.debug('  yCurr=%s', str(yCurr)) 
             lastStep = step
        yRoot = DynO()
        yRoot[lastStep] = yCurr
        eLog.debug( 'path=%s', str(yRoot))     
        return yRoot
    
    def isListNode(self):
        return '_Y_LIST' in self
        
    def merge(self, otherTree):
        eLog.debug( 'Merging tree %s', otherTree)
        merge_dictionary(self, otherTree)
        eLog.debug('Result tree %s', self)
        
    def mergeAll(self, treeList):
        for tree in treeList:
            self.merge(tree)
        
    def mergePath(self, *vs, **kws):
        self.merge(self.path(*vs, **kws))
        return self
        
    def setName(self, name):
        super(DynO, self).__setattr__('_Y_NAME', name)
        
    def getName(self):
        name = super(DynO, self).__getattribute__('_Y_NAME')
        return name
    
    def __repr__(self):
        repr = self.getName()+'('
        vList = list() 
        for k in self.keys():
            v = self[k]
            if isinstance(v, str):
                v = str(v).replace('\n', r'\n')
            if isinstance(self[k], DynO):
                vList.append('%s' % (v,))
            else:
                vList.append('%s=%s' % (k, v))
        repr += (', '.join(vList))
        repr += ')'
        return repr
    
    # TODO: remove. obsolete
    # used if we have several different sources, possibly incomplete, of what are theoretically the same values
    def setValueIfBetter(self, key, value):
        myValue = self.get(key, None)
        if myValue is None or myValue=='':          # if current value is None or empty string
            if not (value is None or value==''):     # and new value is not None or empty string
                self[key] = value                           # set the new value              
    
    # for example, return value of node at end of path 'HL.HL.HL.HL.LIN.LIN04'
    # returns None if tree values 'end' before arriving at final node in path
    def valueOf(self, path):
        if not path:
            return None
        pathNodes = '.'.split(path)
        branchVal = root
        for branch in pathNodes:
            branchVal = branchVal.get(branch, None) # get value of branch or None
            if not branchVal:   # short circuit remainder of path
                return None
        return branchValue

    def satisfiesPreconditions(self):
        return True
        
    def valueFieldsIter(self):
        # only use fields whose names do not start with '_Y_'
        return [key for key in self.keys() if not key.startswith('_Y_')]

    #===================================================================================================================
    # We also act like a dictionary with our attributes
    #===================================================================================================================
    
    def __setitem__(self, key, value):
        self.__dict__.__setitem__(key, value)

    def __getitem__(self, key):
        return self.__dict__.__getitem__(key)
    
    def __contains__(self, key):
        return self.__dict__.__contains__(key)
    
    def __iter__(self):
        return self.__dict__.iteritems()
        
    def get(self, key, defValue=None):
        return self.__dict__.get(key, defValue)
    
    def copy(self):
        newSelf = copy.copy(self)
        newSelf.__dict__ = copy.copy(self.__dict__)
        return newSelf
    
    def clear(self):
        self.__dict__.clear()
    
    def keys(self):
        return self.__dict__.keys()
        
    def values(self):
        return self.__dict__.values()
    
    def update(self, otherDict):
        return self.__dict__.update(otherDict)
    
    def size(self):
        if self.isListNode():
            return len([key for key in self.__dict__ if not key.startswith('_Y_')])
        else:
            return 1
        